:PROPERTIES:
:ID:       e4a6a10f-a305-49fa-91b1-08482df14229
:END:
#+title: a CS skills assessment, with a moderate focus on Python
* the test
** Python's floppy types
*** switching on a dictionary
    Consider this piece of (horrible) Python code:

    if (1 > 2): print (1)
    elif {1:2}: print (2)
    else:       print (3)

    Why does this print "2"?
    What are some advantages and disadvantages of Python's behaving this way,
    instead of throwing an error the way many other languages would?
*** interpretation, and DIY type safety
    Consider this piece of Python code:

    def what_does_this_do ( x : int ) -> bool:
      half = x / 2
      return ( True
               if (half == round(half))
               else False )

    (If you don't know how to read the " : int ) -> bool:" in the first line, that's okay; most Python users don't. That syntax is called "type hints". You can read about it for a very long time here: https://www.python.org/dev/peps/pep-0484/. There must be shorter introductions to the concept online, but I don't know what to recommend. Note that the type hints are optional -- if you wrote the following instead, it would behave exactly the same way:

    def what_does_this_do ( x ):
      half = x / 2
      return ( True
               if (half == round(half))
               else False )

    What does what_does_this_do do?

    If I call what_does_this_do it on a string, it gives me an error:

    >>> what_does_this_do("hello")
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 2, in what_does_this_do
    TypeError: unsupported operand type(s) for /: 'str' and 'int'

    Modify what_does_this_do so that if I give it anything but an integer,
    it will return the string "No thank you."
** factor out a common function
   (This question is written in Python.
   If you'd rather use another language, feel free.
   If the language you choose does not offer type hints,
   you don't have to translate the type hints into your chosen language.)

   Consider this code:

   from typing import List

   def f ( a : List[int]
          ) -> List[int]:
     b = a . copy()
     b . reverse()
     b = [0] + b
     return [ x*2 for x in a + b ]

   def g ( a : List[int]
          ) -> List[int]:
     b = a . copy()
     b . reverse()
     b = [1] + b
     return (a,b)

   In the function bodies of f and g,
   the first two lines are identical,
   and the third lines are almost identical.
   Remove the duplication by writing a new third function h,
   and then rewriting f and g in terms of h,
   so that the bodies of f and g are both only one line long.
** recursion
   (This question is written in Python.
   If you'd rather use another language, feel free.
   If the language you choose does not offer type hints,
   you don't have to translate the type hints into the other language.)

   Consider the following code:

   def is_even (x : int ) -> bool:
     if (x%2 == 0): return True
     else: return False

   def weird ( n : int ) -> int:
     if is_even (n):
       return n / 2
     else:
       return 3*n + 1

   Notice that:
     weird(4) = 2
     weird(2) = 1
   So if I start at 4 and call "weird" repeatedly on the result,
   I eventually get to 1.

   If I do the same thing starting at 16, I also get to 1:
     weird(5) = 16
     weird(16) = 8
     weird(8) = 4
     weird(4) = 2
     weird(2) = 1

   It turns out that for very many positive numbers, maybe all of them,
   this process ends up at 1 (and then cycles: 4-2-1-4-2-1-4-2-1).

   Write a function called count_weirds to count how long it takes to get to 1. For instance:
      count_weirds(1) = 0
      count_weirds(4) = 2
      count_weirds(5) = 5
   count_weirds should be recursive -- that is, no arrays, no for loops, no while loops, etc. It just calls a function (not necessarily itself) over and over until it finds the answer.
** average price across purchases by people with the same employer
   (This question is written in Python.
   If you'd rather use another language, feel free.
   If the language you choose does not offer type hints,
   you don't have to translate the type hints into the other language.)

   Here's some data on people and the stuff they bought:

   import pandas as pd

   people = pd.DataFrame (
     { "name" : ["alice","bob","cindy"],
       "employer" : ["PUJ","PUJ","Microsoft"] } )

   purchases = pd.DataFrame (
     { "name" : [ "alice", "alice", "alice",
                  "bob", "bob",
                  "cindy"],
       "purchase" : [ "dog", "alligator", "Miata",
                      "pizza", "The Complete Works of William Shakespeare",
                      "alligator" ],
       "price" : [ 100, 1e4, 1e5,
                   10, 150,
                   2e4 ] } )

   For instance, Cindy's employer is Microsoft,
   and she only bought one thing, an alligator, which cost her 2e4 dollars.

   Write a function of the following form:

   def price_averaged_within_employer ( people : pd.DataFrame,
                                        purchases : pd.DataFrame,
                                      ) -> pd.DataFrame:
     ...

   to compute the average price of purchases made by people at each employer. For instance, if your function takes the data described above as input, it should produce the table below as output:

              price
   employer
   Microsoft  20000
   PUJ        22052
* the answers
** factor a function
  def h ( a : List[int],
          n : int
         ) -> List[int]:
    b = a . copy()
    b . reverse()
    return [n] + b

  def f2 ( a : List[int]
          ) -> List[int]:
    return [ x*2 for x in a + h(a,0) ]

  def g2 ( a : List[int]
         ) -> List[int]:
    return (a, h(a,1) )

  for s in [ [1,2,3],
             [0,5,0],
             [] ]:
    print(s)
    assert g(s) == g2(s)
** recursion
   def count_weirds ( start : int ) -> int:
     def inner ( n : int, acc = 0 ):
       if n == 1:
          return acc
       else: return inner ( weird(n), acc + 1 )
     return inner ( start )
** average price across purchases by people with the same employer
  def price_averaged_within_employer ( people : pd.DataFrame,
                                       purchases : pd.DataFrame,
                                      ) -> pd.DataFrame:
    return ( purchases.merge ( people,
                               on = "name" )
             . groupby ( "employer" )
             . agg ( "mean" ) )
