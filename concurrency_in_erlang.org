:PROPERTIES:
:ID:       8bd1818b-7da8-4c6b-b35e-93f54ef5a0d7
:END:
#+title: concurrency in Erlang
* RESUME at OTP User Guide
  https://erlang.org/doc/design_principles/des_princ.html
* some vocab
** [[id:0d2d4114-b031-412e-81d7-26bd7c67f7f5][some concurrent programming vocab]]
* errors
  :PROPERTIES:
  :ID:       f68891f2-deaf-47f7-9f8e-ed2ff9f69811
  :END:
  https://erlang.org/doc/reference_manual/errors.html
** kinds of error (error > exception)
*** compile-time errors
**** head mismatch
     "It's possible your function has more than one head, and each of them has a different arity. Don't forget that different arity means different functions, and you can't interleave function declarations that way. This error is also raised when you insert a function definition between the head clauses of another function"
*** logical errors: No crash, just the wrong behavior.
*** "exceptions"
**** three kinds
***** run-time errors: crashes
****** = "exceptions of class error"
****** can be emulated
       :PROPERTIES:
       :ID:       ab30f280-1683-4003-89eb-c94a7dc4997a
       :END:
       erlang:error(Reason)
       erlang:error(Reason, Args)
****** format is {Reason, Stack}
       There's a dictionary of `Reason`s here:
       https://erlang.org/doc/reference_manual/errors.html
       (Search text for "badarith" to find it.)
***** generated errors (two kinds)
****** generated via exit/1 or throw/1
****** = "exceptions of classes exit and throw"
**** stops execution in the host process
     = "failure" | "termination" | "exit"
***** => "emits an exit signal with an exit reason"
**** each has three parts
***** its class,
***** an exit reason
***** a stack trace
      = a list of {Module,Function,Arity,ExtraInfo}
** try-catch blocks
*** TEST: If I know why these commands do what they do, I understand it.
**** first load this code
    black_knight(Attack) when is_function(Attack, 0) ->
        try Attack() of
        _ -> "None shall pass."
        catch
        throw:a -> "It is but a scratch.";
        error:b -> "I've had worse.";
        exit:c -> "Come on you pansy!";
        _ -> "I caught that.";
        exit:_ -> "Run away! Run away!";
        _:_ -> "Just a flesh wound."
        end.
**** then see what these evaluate to
     exceptions:black_knight( fun() -> "Hello." end ).
     exceptions:black_knight( fun() -> throw(a) end ).
     exceptions:black_knight( fun() -> error(b) end ).
     exceptions:black_knight( fun() -> exit(c) end ).
     exceptions:black_knight( fun() -> throw(yikes) end ).
     exceptions:black_knight( fun() -> error(yikes) end ).
     exceptions:black_knight( fun() -> exit(yikes) end ).
**** answers / explanations
     exceptions:black_knight( fun() -> "Hello." end ).
       No exception. Evaluates normally.
     exceptions:black_knight( fun() -> throw(a) end ).
       Matches one of the catch clauses exactly.
     exceptions:black_knight( fun() -> error(b) end ).
       Matches one of the catch clauses exactly.
     exceptions:black_knight( fun() -> exit(c) end ).
       Matches one of the catch clauses exactly.
     exceptions:black_knight( fun() -> throw(yikes) end ).
       Matches the `_`, which because it has no type specified,
       applies only to throws.
     exceptions:black_knight( fun() -> error(yikes) end ).
       Only matches the last, catch-all clause.
     exceptions:black_knight( fun() -> exit(yikes) end ).
       Because it's an exit, it matches the `exit:_` clause;
       its value is ignored.
*** a template
    try
        Expression,
        ...
        Expression
    of
        SuccessfulPattern1 [Guards] ->
         Expression1;
        SuccessfulPattern2 [Guards] ->
         Expression2
    catch
        TypeOfError:ExceptionPattern1 ->
         Expression3;
        TypeOfError:ExceptionPattern2 ->
         Expression4
    after % Always gets executed. Can't return anything.
         Expr3
    end.
*** `try` can distinguish the error class; `catch` can't.
*** `of` defines what gets returned in non-exceptional execution.
*** The `of` and `after` branches are both optional.
*** You can replace TypeOfError by either error, throw or exit.
*** If no type is provided, a throw is assumed.
*** The `after` block always gets executed, return nothing.
    It's good for side effects.
*** PITFALL: Tail call optimization is only available in the `of` branch.
    The `try` and `catch` branches are protected --
    a reference to them must persist in case something goes wrong,
    so the frame can't be optimized away.
*** standalone `catch`
    :PROPERTIES:
    :ID:       38b59abc-ae95-47f2-b23e-d3af81b8d803
    :END:
    It's unnecessary and dangerous. I mostly skipped the section about it:
    https://learnyousomeerlang.com/errors-and-exceptions#theres-more
** The presentation order of errors can be helpful.
   "Most of the time the hardest part is finding which error caused a huge cascade of errors listed against other functions. It is better to resolve compiler errors in the order they were reported to avoid being misled by errors which may not actually be errors at all."
** using throw and catch to skip frames in the stack (upward)
*** The idea
    Normal execution causes each call of a function to hand its result to a caller. For instance, if you descend into a tree, you have to then ascend through it to return the final result.
    By contrast, a `throw` deep in the tree will skip straight to the nearest frame with a `catch` clause.
*** Illustrated here
    The pictures here are the important thing:
    https://learnyousomeerlang.com/errors-and-exceptions#try-a-try-in-a-tree
    There's also the code (search for the word "naive") here:
    file://~/code/concurrent-langs/erlang/tree.erl
* processes
** "process" = "execution thread"
** Processes grow and shrink dynamically.
** spawn() creates processes.
*** spawn/3
    spawn(Module, Exported_Function, Args) -> pid()
      Module, Exported_Function :: atom
      Args :: [term]
*** PITFALL: spawn/1 has a weird lambda requirement
**** why (I think)
     The argument to `spawn` should be *something to run*.
     As such, and maybe because Erlang isn't lazy,
     the function must be unevaluated,
     which means it must be unapplied.
**** example: a list comprehension that spawns stuff
     :PROPERTIES:
     :ID:       b56fe30d-efdd-4ec3-81b8-8b28840185bf
     :END:
     [ spawn(fun() -> G(X) end)
       || X <- lists:seq(1,10) ].

     This, by contrast, does not work:
     [ spawn( G(X) )
       || X <- lists:seq(1,10) ].
*** other varieties
**** spawn/1,2,3,4
**** spawn_link/1,2,3,4
**** spawn_monitor/1,2,3,4
**** spawn_opt/2,3,4,5
**** spawn_request/1,2,3,4,5
** identifying processes
*** All processes have a PID.
**** self/1 returns the pid of the current process.
***** It even works in the shell.
      6> self().
      <0.41.0>
      7> exit(self()).
      ** exception exit: <0.41.0>
      8> self(). %% Now it's a new process.
      <0.285.0>
*** Processes can have names.
**** "To Register" = to name a process.
**** Names are unregistered when the named process terminates.
**** some process name register functions
***** register(Name, Pid)
      Associates the name Name, an atom, with the process Pid.
***** registered()
      Returns a list of names that have been registered using register/2.
***** whereis(Name)
      Returns the pid registered under Name, or undefined if the name is  not registered.
***** regs() -- in repl, get more detailed info on all registered processes.
      :PROPERTIES:
      :ID:       b56be675-c98d-4d98-b1e3-bba982c6abdb
      :END:
**** Definitions can use names that *will be* registered.
     This saves the programmer from having to first create a process and pass its PID (or equivalent) to another process that must talk to it.
*** Processes can have an (alias :: reference).
**** Why references are useful.
     "When the alias has been deactivated, messages sent using the alias will be dropped before entering the message queue of the receiver"
***** but note that
      "messages that at deactivation time already have entered the message queue will not be removed."
**** create an alias
***** Use one of these.
****** alias/0,1
****** monitor/3, spawn_opt(), or spawn_request()
       by passing the {alias, _} option
       In this case the monitor ref and alias are the same ref.
***** Must create the alias *from the process it refers to*.
**** Deactivate an alias
***** with unalias/1
***** called from the aliased process.
**** some surprisingly (intentionally) impossible things
     Make one identifying something other than the caller.
     Deactivate an alias unless it identifies the caller.
     Look up an alias.
     Look up the process identified by an alias.
     Check if an alias is active or not.
     Check if a reference is an alias.
** process termination
*** Termination always sends an "exit reason".
    which can be any term
*** If the reason is 'normal', it "exited normally".
*** Processes can terminate themselves.
    exit(Reason)               ->   Reason
    erlang:error(Reason)       ->  {Reason,Stack}
    erlang:error(Reason, Args) ->  {Reason,Stack}

    `erlang:error/1-2` [[id:ab30f280-1683-4003-89eb-c94a7dc4997a][emulates a runtime crash]].
*** `exit/2 :: PID -> Reason -> IO ()` lets one process kill another.
*** Receiving an abnormal, UNHANDLED EXIT SIGNAL TERMINATES THE receiver.
*** Killing a function kills its subfunctions.
    This includes functions it runs via `apply`,
    but not functions it `spawns` -- the latter are separate processes.
** signals
*** All Erlang communication is via asynchronous signals.
*** message signals and queues
**** Each process has its own message queue.
***** Therefore calls inherit the caller's mailbox.
****** If caller has a nonempty mailbox, a `receive` in a subfunction will immediately read it.
       :PROPERTIES:
       :ID:       a5d0a81c-0856-420a-8d53-23753348d99c
       :END:
       For instance, try running test_inner_receiver().

       receiver_nest() ->
           timer:sleep(1000),
           inner_receiver().

       inner_receiver() ->
           receive X ->
              io:format("You said ~s~n",[X]),
              inner_receiver()
           after 0 ->
              done
           end.

       test_inner_receiver() ->
           Rn = spawn( ?MODULE, receiver_nest, [] ),
           Rn ! "Hi!",
           Rn ! "Bye!".
***** But `spawn` and its ilk create separate processes.
**** Any term can be a message.
**** send messages with `pid ! message`
***** syntax
      The (!) operator is right-associative, so this works:
      pid1 ! pid2 ! message
***** The standard idiom seems to be to include self() in every message.
      Specifically, messages should be (sender's Pid, data) pairs.
**** How `receive` processes messages.
***** syntax
      receive
        Pattern1 -> Expr1;
        ...
        Pattern when Guard -> Expr2
      after <delay in ms> ->
        Expression2
      end
***** Each evaluation of a `receive` expression processes a single message.
***** evaluation order
      First the first message is matched against all patterns.
      Failing that, the second one is,
      and the first one stays in the queue.
      If none match, it blocks for something that does,
      unless it times out.
***** efficiency
      Erlang cleverly "minimizes the number of times each message is tested against the patterns in each receive."
***** PITFALL: maximum timeout duration is about 50 days.
***** `after 0` actually makes sense.
****** Why
       The `receive` clause will still be handled first.
       If there are messages in the mailbox, it will try to match them.
       If none of them match, it will immediately advance to the `after` clause,
       rather than waiting for something that does.
****** [[id:a5d0a81c-0856-420a-8d53-23753348d99c][An example.]]
**** Message delivery is not automatically confirmed.
     "If you need to have a confirmation of delivery, you have to send a second message as a reply to the original process."
**** A default match for messages can prevent accumulating garbage.
***** why
      If an unexpected message is not matched, it will stay in the mailbox,
      slowing the read time for any messages that follow it.
      (jbb: Also it seems good to alert the programmer/user,
      as in the example below,
      to the fact that unexpected messages are being received,
      because by default they occupy the mailbox silently.)
***** example
      receive
          Pattern1 -> Expression1;
          ...
          PatternN -> ExpressionN;
          Unexpected ->
            io:format("unexpected message ~p~n", [Unexpected])
       end.
**** A min-heap is a good model when messages have differing priorities.
     The built-in mailbox is a list.
     If messages are to be stored and then later read in priority order,
     it would make sense to store them in a min-heap (tree),
     such that the largest or smallest is always cheap to find and delete,
     and insertion is cheap too.
     The `gbtrees` library is one option.
*** There are many kinds of signals beyond messages.
    See the list here:
      https://erlang.org/doc/reference_manual/processes.html
    (Search for the text "alive_request/alive_reply".)
*** "User functions" may just forward arguments to a client.
    At least that's true in the toy examples I've seen.
    There will be some looping client process,
    and the "user functions" (called from the repl)
    do nothing but send messages to the client.
** "Distributed Programming": processes across many CPUs
   https://erlang.org/doc/getting_started/conc_prog.html
*** Erlang cookies
**** Each Erlang needs a ".erlang.cookie" file.
     It should be the same atom. (Max length 255 chars.)
**** Must `chmod 400 .erlang.cookie`.
*** Each Erlang instance must have a name
    $ erl -sname my_name
*** Messaging works largely the same across CPUs.
**** but names are longer, specifying the Erlang node too.
***** Direct messages to {registered_name, Node} rather than just to `registered_name`.
***** how to discover the Node name
      In general I'm not sure,
      but at least when running locally,
      I can start a repl with `erl -sname bob`
      and then I'd get this for a prompt:
        (bob@jbb-dell)1>
      which tells me my Node is called `jbb-dell`.
** Linking processes
*** Linking P to its dependencies lets them crash together.
*** Links are bidirectional.
    They can be created from either end, i.e. either process.
*** How exit messages are treated by default.
    serial
**** Bypass all messages to the receiving process.
**** Kill the receiving process.
**** Propagate the same error signal to the links of the killed process.
*** Restarting them as a group is typically  easier.
*** creating links
**** Use `link/1` and `unlink/1` :: PID -> IO ().
**** Use `spawn_link` to create and link simultaneously.
     (link . spawn) is sequential.
     `spawn_link` is atomic, hence safer:
     The spawn cannot die before being linked.
*** If P exits normally, processes linked to P stay up.
*** Processes can be linked to the repl.
    This is one way to see it when they crash.
** handling errors
*** processes robust to receiving exit signals
**** To make one so, run `process_flag(trap_exit, true)`.
**** Such processes receive exit signals as normal messages.
     in the format {'EXIT',FromPID,Reason}
*** linking to a non-existent process
    causes an exit signal, {'EXIT',From,noproc},
    to be automatically generated.
    It is as if the process terminated immediately
    after the link operation.
* notes from LYSE, distrusted
** Show and delete messages to the repl with flush/0.
   :PROPERTIES:
   :ID:       0dfa99f9-7d57-4d9d-b664-728d6b916ea8
   :END:
** Coordinating process errors.
*** TODO Much of this chapter I did not understand.
    :PROPERTIES:
    :ID:       4513bc08-e581-4009-b992-7b1e3c903c9a
    :END:
    https://learnyousomeerlang.com/errors-and-processes
*** "Monitors" are directed, stackable links.
**** TODO what does "stackable" mean?
     I suspect it means there can be more than one link from A to B.
     But part of LYSE suggested it means that,
     if A is linked to B which is linked to C,
     unlinking A from B leaves the link from B to C intact.
**** TODO I didn't fully understand the Monitors section.
     https://learnyousomeerlang.com/errors-and-processes#monitors
**** Two processes can both monitor each other.
     If either fails, the other will be notified, but not taken down.
**** Create monitor links with erlang:monitor/2 :: Atom -> PID -> IO (monitor reference).
***** PITFALL: The first arg is always the atom `process`.
**** When a process goes down, its monitor receives a message of the form
     {'DOWN', MonitorReference, process, Pid, Reason}
***** TODO is that the only kind of message a monitor relationship generates?
      :PROPERTIES:
      :ID:       cac7b800-f386-47e0-9cde-0e7cba38c718
      :END:
**** spawn_monitor/1-3 are atomic, like spawn_link/1-3.
     They return a pair:
       {Pid of new process, Ref of new monitor relationship}
**** Use `erlang:demonitor/1` to end a monitoring relationship.
*** Attach a "Ref", not just a Pid, to any message that requires a reply.
    That way, if A sends to B and receives a reply,
    and B's reply includes the same Ref,
    then A knows what B is talking about.
*** It's common to export `start` and `start_link` functions.
    They correspond to spawn and spawn_link.
    They permit the programmer to hide implementation details from the user.
*** checking if a process exists
**** example
     https://learnyousomeerlang.com/designing-a-concurrent-application#understanding-the-problem
     cancel(Pid) ->
       %% Monitor in case the process is already dead
       Ref = erlang:monitor(process, Pid),
       Pid ! {self(), Ref, cancel}, % Tell it to stop.
       receive
         {Ref, ok} -> % It was already down.
           erlang:demonitor(
             Ref,
             [flush]), % "purge the DOWN message if it was sent before
                       %  we had the time to demonitor"
           ok;
         {'DOWN', Ref, process, Pid, _Reason} ->
           ok
       end.
**** TODO does this mean a monitor receives a "DOWN" message even if it's created after the process being watched goes down?
**** TODO Why flush a monitoring function that's about to end anyway?
     Is that because it shares a mailbox with whatever called it?
*** The reference to a monitor can be a good key for a store of clients.
    Ref = erlang:monitor(process, Client),
    NewClients =
      orddict:store(
        Ref, % "the only other time we'll need to fetch the client ID will be if we receive [EXIT from the monitor], which will contain" REF. https://learnyousomeerlang.com/designing-a-concurrent-application#understanding-the-problem
        Client,
        S#state.clients), % the map to modify
** The OTP library
*** gen_server: the Generic Server module|behavior
    https://learnyousomeerlang.com/clients-and-servers#callback-to-the-future
**** some "callbacks": functions the user must define *and export*
     If they aren't exported, gen_server can't use them, I guess.
***** init/1
****** called by gen_server:start and gen_server:start_link
****** messages it can return
******* {ok, State}
******* {ok, State, TimeOut}
        "The TimeOut variable is meant to be added to the tuple whenever you need a deadline before which you expect the server to receive a message. If no message is received before the deadline, a special one (the atom timeout) is sent to the server, which should be handled with handle_info/2 (more on this later.)"
******* {ok, State, hibernate}
        "if you do expect the process to take a long time before getting a reply and are worried about memory, you can add the hibernate atom to the tuple. Hibernation basically reduces the size of the process' state until it gets a message, at the cost of some processing power. If you are in doubt about using hibernation, you probably don't need it."
******* {stop, Reason}
        When initialization fails.
******* ignore
****** whatever calls init/1 blocks until it returns
       It is waiting for a `ready` message
       from the `gen_server` module.
***** handle_call :: (Request, From, State) -> <response>
      :PROPERTIES:
      :ID:       bc1f3d25-47cb-4210-a43c-8787f3e744e3
      :END:
****** called by gen_server:call
****** for synchronous messaging
****** valid response formats
******* {reply,Reply,NewState}
******* {reply,Reply,NewState,Timeout}
******* {reply,Reply,NewState,hibernate}
******* {noreply,NewState}
******* {noreply,NewState,Timeout}
******* {noreply,NewState,hibernate}
******* {stop,Reason,Reply,NewState}
******* {stop,Reason,NewState}
****** how the terms in those messages work
******* `TimeOut` and `hibernate` work like in init/1.
******* `Reply` is sent back to whoever asked for it.
******* `noreply` tells the server not to reply.
        :PROPERTIES:
        :ID:       26114ed6-ebd8-4ccd-a525-0d3fc7aba7da
        :END:
        "you're taking care of sending the reply back yourself."
        Do so with gen_server:reply/2.
***** handle_cast :: (Message, State) -> <response>
      :PROPERTIES:
      :ID:       ce8cbd61-4465-4452-ae19-753b6a227ddd
      :END:
****** called by gen_server:cast
****** for asynchronous messaging
****** much like [[id:bc1f3d25-47cb-4210-a43c-8787f3e744e3][handle_call]]
****** valid response formats
       {noreply,NewState}
       {noreply,NewState,Timeout}
       {noreply,NewState,hibernate}
       {stop,Reason,NewState}
***** handle_info/2 : handle messages outside the interface
****** a quote
       "similar to [[id:ce8cbd61-4465-4452-ae19-753b6a227ddd][handle_cast/2]] and in fact returns the same tuples. The difference is that this callback is only there for messages that were sent directly with the ! operator and special ones like init/1's timeout, monitors' notifications and 'EXIT' signals."
****** Valid response formats include
       but might not be limited to
******* {noreply, Cats}
****** But remember they can do IO too.
       A natural implementation would be to log the unexpected messages.
***** terminate/2 :: (Reason, State) -> <dunno>
****** called in response to `{stop, ...}` tuples
       {stop, Reason, NewState}
       {stop, Reason, Reply, NewState}
****** valid Reason values
******* are these
        normal
        shutdown
        {shutdown, Term}
******* if Reason fits none of those patterns, logging happens
        "If any reason other than normal, shutdown or {shutdown, Term} is used when terminate/2 is called, the OTP framework will see this as a failure and start logging a bunch of stuff here and there for you."
****** might be called if its parent (spawner) dies
       That happens if and only if
       the gen_server is trapping exits.
****** is like the opposite of init/1
****** return value doesn't matter
       "the code stops executing after it's been called"
***** code_change/3 :: (PrevVersion, State, Extra) -> {ok, NewState}
****** valid PreviousVersion values
       either the version term itself in the case of an upgrade
       or {down, Version} in the case of a downgrade
****** State is the current server's state
****** Extra is advanced stuff.
**** some functions a user is likely to define
***** offload `start_link` to `gen_server`
      start_link () -> % returns {ok,Pid}
        gen_server:start_link(
          % optional fourth parameter in first (this) position:
          % name to register server under
          ?MODULE,  % where the callbacks are
          [],       % parameters for init/1
          []).    % debugging options
***** gen_server:call :: Pid -> Message -> _ -> IO ()
      The Pid is, I imagine, who sent the message.
      The optional (i.e. can be missing entirely)
      third argument is a timeout, defaulting to 5 seconds.
**** gen_server:reply/2
     Useful when you'd like to [[id:26114ed6-ebd8-4ccd-a525-0d3fc7aba7da][handle the reply yourself]],
     rather than using the server.
**** TODO What do I have to export?
     c.f. ~/code/concurrent-langs/erlang/kitty/v3-otp/kitty_gen_server.erl
     If I export_all it works.
     If I try to export only the interface, it doesn't.
*** gen_fsm: the Generic Finite State Machine module|behavior
    https://learnyousomeerlang.com/finite-state-machines
**** looks like a digraph
**** callback the user must define
***** in all of these, `stop`, Timeout and `hibernate` work the same as in `gen_server`.
***** init/1
****** acceptable return values
       {ok, StateName, Data}
       {ok, StateName, Data, Timeout}
       {ok, StateName, Data, hibernate}
       {stop, Reason}
****** the `StateName` atom indicates the next callback to use
***** StateName/2-3
      For each state defined in `init`,
      there should be at least one function of the same name.
      taking 2 arguments if async, 3 if sync.
****** For a given StateName, *either or both* StateName/2 and StateName/3 can be defined.
****** StateName/2 :: EventMessage -> StateData -> _
******* valid return values
        {next_state, NextStateName, NewStateData}
        {next_state, NextStateName, NewStateData, Timeout}
        {next_state, NextStateName, NewStateData, hibernate}
        {stop, Reason, NewStateData}
****** StateName/3 :: EventMessage -> From -> StateData -> _
******* valid return values
       {reply, Reply, NextStateName, NewStateData}
       {reply, Reply, NextStateName, NewStateData, Timeout}
       {reply, Reply, NextStateName, NewStateData, hibernate}

       {next_state, NextStateName, NewStateData}
       {next_state, NextStateName, NewStateData, Timeout}
       {next_state, NextStateName, NewStateData, hibernate}

       {stop, Reason, Reply, NewStateData}
       {stop, Reason, NewStateData}
***** handle_event/3 :: EventMessage -> StateName -> StateData -> _
****** for events that are handled the same from every state
       (So it seems strange that StateName is an argument ...)
****** is for async events, I think
***** handle_sync_event/4 ::
****** for synchronous global events
****** "takes the same parameters and returns the same kind of tuples as StateName/3."
***** code_change/4
****** like the same function in gen_servers
****** input: (OldVersion, StateName, Data, Extra)
****** output: {ok, NextStateName, NewStateData}
***** terminate/3
**** sending (async, sync) events to (some, every) state -> four functions
***** send_event/2
      Asynchronous events aimed at any StateName/2 function
***** sync_send_event/2-3
      "synchronous events to be picked up by [any?] StateName/3"
***** send_all_state_event/2 and sync_send_all_state_event/2-3
      "Equivalent" to the previous two, but for "global" events.
****** TODO "global" events?
**** [[id:306ceafe-96fd-4076-87e3-81a617b0d99c][synchronous vs. asynchronous communication: when to prefer which]]
**** [[id:b0957f0c-b592-4906-be93-638476a45b20][designing asynchronous protocols]]
*** gen_event: the Generic Events module|behavior
    https://learnyousomeerlang.com/event-handlers
**** "event handlers run in the same process as their manager"
**** callbacks the user must define
***** init/1
      takes a list of arguments and returns {ok, State}.
***** terminate/2
***** handle_event :: (Event, State) -> _
****** asynchronous
****** acceptable return values
******* {ok, NewState}
        replies to nobody
******* {ok, NewState, hibernate}
        puts the event manager itself into hibernation until the next event
******* remove_handler
        "drops the handler from the manager"
        Good for when the handler is finished.
******* {swap_handler, Args1, NewState, NewHandler, Args2}
        Rarely used.
        Calls these in serial:
          CurrentHandler:terminate(Args1, NewState)
          NewHandler:init(Args2, ResultFromTerminate)
****** triggered by `gen_event:notify/2`
***** handle_call
****** acceptable return values
       {ok, Reply, NewState}
       {ok, Reply, NewState, hibernate}
       {remove_handler, Reply}
       {swap_handler, Reply, Args1, NewState, Handler2, Args2}
****** "like gen_server:handle_call`
       Does that mean its inputs are (Request, From, State)?
****** triggered by `gen_event:call/3-4`
***** handle_info/2
      For unexpected messages.
***** code_change :: (OldVsn, State, Extra) -> _
****** like in gen_server
****** applies to each event handler individually
****** can return {ok, NewState}
       and maybe other stuff
**** functions it defines
***** gen_event:notify/2 :: async
***** gen_event:sync_notify/2 :: sync
      "returns once all event handlers have seen and treated the new message. Until then, the event manager will keep blocking the calling process by not replying."

** Supervisors
*** Can restart dead processes.
*** A DIY supervisor.
    -module(sup). % "supervisor"
    -export(
       [ start/2
       , start_link/2
       , init/1
       , loop/1]).

    start(Mod,Args) ->
      spawn(
        ?MODULE,
        init,
        [ { Mod % Any module with a start_link function.
          , Args % Any tuple matching Mod:start_link's arity.
          } ] ).

    start_link(Mod,Args) ->
      spawn_link( ?MODULE, init, [{Mod, Args}] ).

    init({Mod,Args}) ->
      process_flag(trap_exit, true),
      loop({Mod,start_link,Args}).

    loop({M,F,A}) ->
      Pid = apply(M,F,A),
      receive
        {'EXIT', _From, shutdown} ->
          exit(shutdown); % will kill the child too
        {'EXIT', Pid, Reason} ->
          io:format(
        "Process ~p exited for reason ~p~n",
        [Pid,Reason]),
          loop({M,F,A})
      end.
