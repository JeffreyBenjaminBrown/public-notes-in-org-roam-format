:PROPERTIES:
:ID:       8bd1818b-7da8-4c6b-b35e-93f54ef5a0d7
:END:
#+title: concurrency in Erlang
* some vocab
** [[id:0d2d4114-b031-412e-81d7-26bd7c67f7f5][some concurrent programming vocab]]
* Erlang , errors in
  :PROPERTIES:
  :ID:       f68891f2-deaf-47f7-9f8e-ed2ff9f69811
  :END:
  https://erlang.org/doc/reference_manual/errors.html
** kinds of error (error > exception)
*** compile-time errors
**** head mismatch
     "It's possible your function has more than one head, and each of them has a different arity. Don't forget that different arity means different functions, and you can't interleave function declarations that way. This error is also raised when you insert a function definition between the head clauses of another function"
*** logical errors: No crash, just the wrong behavior.
*** "exceptions"
**** three kinds
***** run-time errors: crashes
****** = "exceptions of class error"
****** can be emulated
       :PROPERTIES:
       :ID:       ab30f280-1683-4003-89eb-c94a7dc4997a
       :END:
       erlang:error(Reason)
       erlang:error(Reason, Args)
****** format is {Reason, Stack}
       There's a dictionary of `Reason`s here:
       https://erlang.org/doc/reference_manual/errors.html
       (Search text for "badarith" to find it.)
***** generated errors (two kinds)
****** generated via exit/1 or throw/1
****** = "exceptions of classes exit and throw"
**** stops execution in the host process
     = "failure" | "termination" | "exit"
***** => "emits an exit signal with an exit reason"
**** each has three parts
***** its class,
***** an exit reason
***** a stack trace
      = a list of {Module,Function,Arity,ExtraInfo}
** try-catch blocks
*** TEST: If I know why these commands do what they do, I understand it.
**** first load this code
    black_knight(Attack) when is_function(Attack, 0) ->
        try Attack() of
        _ -> "None shall pass."
        catch
        throw:a -> "It is but a scratch.";
        error:b -> "I've had worse.";
        exit:c -> "Come on you pansy!";
        _ -> "I caught that.";
        exit:_ -> "Run away! Run away!";
        _:_ -> "Just a flesh wound."
        end.
**** then see what these evaluate to
     exceptions:black_knight( fun() -> "Hello." end ).
     exceptions:black_knight( fun() -> throw(a) end ).
     exceptions:black_knight( fun() -> error(b) end ).
     exceptions:black_knight( fun() -> exit(c) end ).
     exceptions:black_knight( fun() -> throw(yikes) end ).
     exceptions:black_knight( fun() -> error(yikes) end ).
     exceptions:black_knight( fun() -> exit(yikes) end ).
**** answers / explanations
     exceptions:black_knight( fun() -> "Hello." end ).
       No exception. Evaluates normally.
     exceptions:black_knight( fun() -> throw(a) end ).
       Matches one of the catch clauses exactly.
     exceptions:black_knight( fun() -> error(b) end ).
       Matches one of the catch clauses exactly.
     exceptions:black_knight( fun() -> exit(c) end ).
       Matches one of the catch clauses exactly.
     exceptions:black_knight( fun() -> throw(yikes) end ).
       Matches the `_`, which because it has no type specified,
       applies only to throws.
     exceptions:black_knight( fun() -> error(yikes) end ).
       Only matches the last, catch-all clause.
     exceptions:black_knight( fun() -> exit(yikes) end ).
       Because it's an exit, it matches the `exit:_` clause;
       its value is ignored.
*** a template
    try
        Expression,
        ...
        Expression
    of
        SuccessfulPattern1 [Guards] ->
         Expression1;
        SuccessfulPattern2 [Guards] ->
         Expression2
    catch
        TypeOfError:ExceptionPattern1 ->
         Expression3;
        TypeOfError:ExceptionPattern2 ->
         Expression4
    after % Always gets executed. Can't return anything.
         Expr3
    end.
*** `try` can distinguish the error class; `catch` can't.
*** `of` defines what gets returned in non-exceptional execution.
*** The `of` and `after` branches are both optional.
*** You can replace TypeOfError by either error, throw or exit.
*** If no type is provided, a throw is assumed.
*** The `after` block always gets executed, return nothing.
    It's good for side effects.
*** PITFALL: Tail call optimization is only available in the `of` branch.
    The `try` and `catch` branches are protected --
    a reference to them must persist in case something goes wrong,
    so the frame can't be optimized away.
*** standalone `catch`
    :PROPERTIES:
    :ID:       38b59abc-ae95-47f2-b23e-d3af81b8d803
    :END:
    It's unnecessary and dangerous. I mostly skipped the section about it:
    https://learnyousomeerlang.com/errors-and-exceptions#theres-more
** The presentation order of errors can be helpful.
   "Most of the time the hardest part is finding which error caused a huge cascade of errors listed against other functions. It is better to resolve compiler errors in the order they were reported to avoid being misled by errors which may not actually be errors at all."
** using throw and catch to skip frames in the stack (upward)
*** The idea
    Normal execution causes each call of a function to hand its result to a caller. For instance, if you descend into a tree, you have to then ascend through it to return the final result.
    By contrast, a `throw` deep in the tree will skip straight to the nearest frame with a `catch` clause.
*** Illustrated here
    The pictures here are the important thing:
    https://learnyousomeerlang.com/errors-and-exceptions#try-a-try-in-a-tree
    There's also the code (search for the word "naive") here:
    file://~/code/concurrent-langs/erlang/tree.erl
* [[id:b5343c52-fe16-4579-8ac1-7567ed0db8c5][signals]]
* processes
** "process" = "execution thread"
** Processes grow and shrink dynamically.
** spawn() creates processes.
*** spawn/3
    spawn(Module, Exported_Function, Args) -> pid()
      Module, Exported_Function :: atom
      Args :: [term]
*** PITFALL: spawn/1 has a weird lambda requirement
**** why (I think)
     The argument to `spawn` should be *something to run*.
     As such, and maybe because Erlang isn't lazy,
     the function must be unevaluated,
     which means it must be unapplied.
**** example: a list comprehension that spawns stuff
     :PROPERTIES:
     :ID:       b56fe30d-efdd-4ec3-81b8-8b28840185bf
     :END:
     [ spawn(fun() -> G(X) end)
       || X <- lists:seq(1,10) ].

     This, by contrast, does not work:
     [ spawn( G(X) )
       || X <- lists:seq(1,10) ].
*** other varieties
**** spawn/1,2,3,4
**** spawn_link/1,2,3,4
**** spawn_monitor/1,2,3,4
**** spawn_opt/2,3,4,5
**** spawn_request/1,2,3,4,5
** identifying processes
*** All processes have a PID.
**** self/1 returns the pid of the current process.
***** It even works in the shell.
      6> self().
      <0.41.0>
      7> exit(self()).
      ** exception exit: <0.41.0>
      8> self(). %% Now it's a new process.
      <0.285.0>
*** Processes can have names.
**** "To Register" = to name a process.
**** Names are unregistered when the named process terminates.
**** some process name register functions
***** register(Name, Pid)
      Associates the name Name, an atom, with the process Pid.
***** registered()
      Returns a list of names that have been registered using register/2.
***** whereis(Name)
      Returns the pid registered under Name, or undefined if the name is  not registered.
***** regs() -- in repl, get more detailed info on all registered processes.
      :PROPERTIES:
      :ID:       b56be675-c98d-4d98-b1e3-bba982c6abdb
      :END:
**** Definitions can use names that *will be* registered.
     This saves the programmer from having to first create a process and pass its PID (or equivalent) to another process that must talk to it.
*** Processes can have an (alias :: reference).
**** Why references are useful.
     "When the alias has been deactivated, messages sent using the alias will be dropped before entering the message queue of the receiver"
***** but note that
      "messages that at deactivation time already have entered the message queue will not be removed."
**** create an alias
***** Use one of these.
****** alias/0,1
****** monitor/3, spawn_opt(), or spawn_request()
       by passing the {alias, _} option
       In this case the monitor ref and alias are the same ref.
***** Must create the alias *from the process it refers to*.
**** Deactivate an alias
***** with unalias/1
***** called from the aliased process.
**** some surprisingly (intentionally) impossible things
     Make one identifying something other than the caller.
     Deactivate an alias unless it identifies the caller.
     Look up an alias.
     Look up the process identified by an alias.
     Check if an alias is active or not.
     Check if a reference is an alias.
** process termination
*** Termination always sends an "exit reason".
    which can be any term
*** If the reason is 'normal', it "exited normally".
*** Processes can terminate themselves.
    exit(Reason)               ->   Reason
    erlang:error(Reason)       ->  {Reason,Stack}
    erlang:error(Reason, Args) ->  {Reason,Stack}

    `erlang:error/1-2` [[id:ab30f280-1683-4003-89eb-c94a7dc4997a][emulates a runtime crash]].
*** `exit/2 :: PID -> Reason -> IO ()` lets one process kill another.
*** Receiving an abnormal, UNHANDLED EXIT SIGNAL TERMINATES THE receiver.
*** Killing a function kills its subfunctions.
    This includes functions it runs via `apply`,
    but not functions it `spawns` -- the latter are separate processes.
** Erlang , signals in
   :PROPERTIES:
   :ID:       b5343c52-fe16-4579-8ac1-7567ed0db8c5
   :END:
*** All Erlang communication is via asynchronous signals.
*** message signals and queues
**** Each process has its own message queue.
***** Therefore calls inherit the caller's mailbox.
****** If caller has a nonempty mailbox, a `receive` in a subfunction will immediately read it.
       :PROPERTIES:
       :ID:       a5d0a81c-0856-420a-8d53-23753348d99c
       :END:
       For instance, try running test_inner_receiver().

       receiver_nest() ->
           timer:sleep(1000),
           inner_receiver().

       inner_receiver() ->
           receive X ->
              io:format("You said ~s~n",[X]),
              inner_receiver()
           after 0 ->
              done
           end.

       test_inner_receiver() ->
           Rn = spawn( ?MODULE, receiver_nest, [] ),
           Rn ! "Hi!",
           Rn ! "Bye!".
***** But `spawn` and its ilk create separate processes.
**** Any term can be a message.
**** send messages with `pid ! message`
***** syntax
      The (!) operator is right-associative, so this works:
      pid1 ! pid2 ! message
***** The standard idiom seems to be to include self() in every message.
      Specifically, messages should be (sender's Pid, data) pairs.
**** How `receive` processes messages.
***** syntax
      receive
        Pattern1 -> Expr1;
        ...
        Pattern when Guard -> Expr2
      after <delay in ms> ->
        Expression2
      end
***** Each evaluation of a `receive` expression processes a single message.
***** evaluation order
      First the first message is matched against all patterns.
      Failing that, the second one is,
      and the first one stays in the queue.
      If none match, it blocks for something that does,
      unless it times out.
***** efficiency
      Erlang cleverly "minimizes the number of times each message is tested against the patterns in each receive."
***** PITFALL: maximum timeout duration is about 50 days.
***** `after 0` actually makes sense.
****** Why
       The `receive` clause will still be handled first.
       If there are messages in the mailbox, it will try to match them.
       If none of them match, it will immediately advance to the `after` clause,
       rather than waiting for something that does.
****** [[id:a5d0a81c-0856-420a-8d53-23753348d99c][An example.]]
**** Message delivery is not automatically confirmed.
     "If you need to have a confirmation of delivery, you have to send a second message as a reply to the original process."
**** A default match for messages can prevent accumulating garbage.
***** why
      If an unexpected message is not matched, it will stay in the mailbox,
      slowing the read time for any messages that follow it.
      (jbb: Also it seems good to alert the programmer/user,
      as in the example below,
      to the fact that unexpected messages are being received,
      because by default they occupy the mailbox silently.)
***** example
      receive
          Pattern1 -> Expression1;
          ...
          PatternN -> ExpressionN;
          Unexpected ->
            io:format("unexpected message ~p~n", [Unexpected])
       end.
**** A min-heap is a good model when messages have differing priorities.
     The built-in mailbox is a list.
     If messages are to be stored and then later read in priority order,
     it would make sense to store them in a min-heap (tree),
     such that the largest or smallest is always cheap to find and delete,
     and insertion is cheap too.
     The `gbtrees` library is one option.
*** There are many kinds of signals beyond messages.
    See the list here:
      https://erlang.org/doc/reference_manual/processes.html
    (Search for the text "alive_request/alive_reply".)
*** "User functions" may just forward arguments to a client.
    At least that's true in the toy examples I've seen.
    There will be some looping client process,
    and the "user functions" (called from the repl)
    do nothing but send messages to the client.
* coordinating processes
** "Distributed Programming": processes across many CPUs
   https://erlang.org/doc/getting_started/conc_prog.html
*** Erlang cookies
**** Each Erlang needs a ".erlang.cookie" file.
     It should be the same atom. (Max length 255 chars.)
**** Must `chmod 400 .erlang.cookie`.
*** Each Erlang instance must have a name
    $ erl -sname my_name
*** Messaging works largely the same across CPUs.
**** but names are longer, specifying the Erlang node too.
***** Direct messages to {registered_name, Node} rather than just to `registered_name`.
***** how to discover the Node name
      In general I'm not sure,
      but at least when running locally,
      I can start a repl with `erl -sname bob`
      and then I'd get this for a prompt:
        (bob@jbb-dell)1>
      which tells me my Node is called `jbb-dell`.
** Linking processes
*** Linking P to its dependencies lets them crash together.
*** Links are bidirectional.
    They can be created from either end, i.e. either process.
*** How exit messages are treated by default.
    serial
**** Bypass all messages to the receiving process.
**** Kill the receiving process.
**** Propagate the same error signal to the links of the killed process.
*** Restarting them as a group is typically  easier.
*** creating links
**** Use `link/1` and `unlink/1` :: PID -> IO ().
**** Use `spawn_link` to create and link simultaneously.
     (link . spawn) is sequential.
     `spawn_link` is atomic, hence safer:
     The spawn cannot die before being linked.
*** If P exits normally, processes linked to P stay up.
*** Processes can be linked to the repl.
    This is one way to see it when they crash.
** handling errors
*** processes robust to receiving exit signals
**** To make one so, run `process_flag(trap_exit, true)`.
**** Such processes receive exit signals as normal messages.
     in the format {'EXIT',FromPID,Reason}
*** linking to a non-existent process
    causes an exit signal, {'EXIT',From,noproc},
    to be automatically generated.
    It is as if the process terminated immediately
    after the link operation.
** [[id:81311222-bb74-441c-b4ec-42501e8784b7][the four standard OTP behaviors]]
* the four standard OTP behaviors
  :PROPERTIES:
  :ID:       81311222-bb74-441c-b4ec-42501e8784b7
  :END:
  "gen" stands for "generic"
** gen_server
*** an intro
    https://erlang.org/doc/design_principles/gen_server_concepts.html
*** It's simple!
*** It's for managing a central resource
    one that various clients need to access.
*** some gen_server functions
**** gen_server:start_link
***** It starts the server.
***** It is synchronous.
      It will not return until the server has started.
***** Callback modules often wrap that function, like so.
      start_link() ->
        gen_server:start_link({local, ch3}, ch3, [], []).
***** `gen_server:start_link` calls the `init` callback
      if name registration succeeds first.
***** `gen_server:start_link` is required if the server is part of a supervision tree.
***** TODO What does `gen_server:start_link` link to?
      :PROPERTIES:
      :ID:       d0708b3c-265f-41cc-b0b9-e848ed5f79d3
      :END:
**** gen_server:call( Server_name, message ).
     Sends `message` to the server.
     Server_name must be what was used in start_link.
     Triggers [[id:1a46e14d-895c-4845-aef9-53241179fe0e][`handle_call`]] in the server.
     The client blocks (I believe)
     until it gets the server's response.
**** gen_server:cast/2( Server_name, message )
     For asynchronoous communication.
     Sends `message` to the server and returns `ok`.
*** some gen_server callbacks
**** `handle_call`
     :PROPERTIES:
     :ID:       1a46e14d-895c-4845-aef9-53241179fe0e
     :END:
     handle_call(Request, From, State) =>
       {reply,Reply,NewServerState}.
**** `handle_cast`
     handle_cast(Request, State) => {noreply,NewServerState}
**** `init/1`
     `gen_server:start_link` calls this.
     It should return `{ok,State}` if it succeeds.
**** `handle_info`
     It handles unexpected messages.
     handle_info(Info, State) => {noreply, State1}
**** `code_change`
     code_change(OldVsn, State, Extra) ->
       %% Insert here: Code to convert state (and more)
       %% during code change.
       {ok, NewState}.
*** PITFALL: Stopping is subtle.
    https://erlang.org/doc/design_principles/gen_server_concepts.html#stopping
    If the server is part of a supervision tree,
    it *might* need to clean up before stopping.
    If it's not, one *must* define how to stop.
** gen_statem
   https://erlang.org/doc/design_principles/statem.html
*** TODO I didn't finish this chapter.
    I read enough to think I could write a basic one.
    But there are a lot of options I don't know how to use.
**** Resume at OTP/statem in "design principles"
     https://erlang.org/doc/design_principles/statem.html
     "The code is explained in the next sections."
*** It appears to generalize gen_server.
*** the concept
    gen_statem will update a State whenever there is an Event.
    It also "keeps a server Data",
    which makes it Turing-complete,
    but "it feels mostly like an Event-Driven Mealy machine".
*** the callbacks
**** "callback mode"
***** Two Alternatives. "state functions" is better.
****** "state functions": Define one callback for each state.
       The state is an atom.
******* I believe this is no real restriction,
        thanks to the `Server Data` which is statelike
        and of unrestricted type.
****** "handle_event_function": A singlecallback for all states.
***** define it with callback_mode/0
      example:
      callback_mode() ->
        state_functions.
**** the state callback(s)
     (Plural if callback mode() = state_functions.)
***** They each get [[id:d6131c82-f4df-404b-9dd7-6c07a6c3d659][Event Type and Event Content]] args.
***** When working normally, should return one of these.
      {next_state, NextState, NewData, [[id:3541b431-e9f6-427f-9b6a-c282fc2dc440][TransitionActions]]}
      {next_state, NextState, NewData}
****** Other options are unnecessary but maybe clearer.
       {keep_state, NewData, [[id:3541b431-e9f6-427f-9b6a-c282fc2dc440][TransitionActions]]}
       {keep_state, NewData}
       {keep_state_and_data, [[id:3541b431-e9f6-427f-9b6a-c282fc2dc440][TransitionActions]]}
       keep_state_and_data
       {repeat_state, NewData, [[id:3541b431-e9f6-427f-9b6a-c282fc2dc440][TransitionActions]]}
       {repeat_state, NewData}
       {repeat_state_and_data, [[id:3541b431-e9f6-427f-9b6a-c282fc2dc440][TransitionActions]]}
       repeat_state_and_data
***** When it has to stop, should return one of these.
      {stop, Reason, NewData}
      {stop, Reason}
       Stop the server with reason Reason.
         If the NewData field is used, first
       update the server data.

      {stop_and_reply, Reason, NewData, ReplyActions}
      {stop_and_reply, Reason, ReplyActions}
        Same as the stop values,
        but first execute the given [[id:3541b431-e9f6-427f-9b6a-c282fc2dc440][TransitionActions]]
        that may only be reply actions.
***** When the new state differs from the old, more happens.
****** It restarts the event queue the oldest postponed event.
****** Any current state time-out is cancelled.
****** If " state enter calls" are enabled, one happens.
**** init/1
     => {ok, State, Data}
     or {ok, State, Data, TransitionActions}.
***** postponing is meaningless here
      "If you use the postpone action from this function, that action is ignored, since there is no event to postpone."
*** transition actions
    :PROPERTIES:
    :ID:       3541b431-e9f6-427f-9b6a-c282fc2dc440
    :END:
    https://erlang.org/doc/design_principles/statem.html#Transition%20Actions
    Complicated, maybe esoteric, don't seem important for now.
*** event types & event content
    :PROPERTIES:
    :ID:       d6131c82-f4df-404b-9dd7-6c07a6c3d659
    :END:
**** are handed in pairs to the state callbacks.
**** some event types
***** cast
      come from gen_statem:cast(ServerRef, Msg).
      Msg becomes the event content.
***** {call,From}
      come from gen_statem:call(ServerRef, Request).
      Request becomes the event content.
***** There are others I didn't understand.
** gen_event
*** the idea
**** It lets you create an "event manager".
**** It keeps a [(Event handler, Event handler state)].
***** Each event handler is implemented as a callback module.
***** The manager's state is, more specifically
      "a list of {Module, State} pairs, where each Module is an event handler, and State is the internal state of that event handler."
**** Every event handler handles every event.
*** functions it defines
**** to start the manager: gen_event:start_link
***** local registry
      This:
        gen_event:start_link({local, Event_manager_name})
      registers it locally under the name Event_manager_name.
***** global registry: Use {global, Name} instead.
***** Like gen_server, there's also a [[id:d0708b3c-265f-41cc-b0b9-e848ed5f79d3][`start` alternative of `start_link`]].
**** to add event handlers to it: gen_event:add_handler
     gen_event:add_handler( manager, handler, HandlerArgs).
     It calls handler:init( HandlerArgs ).
**** to handle events: gen_event:notify
     gen_event:notify( EventManager, Event )
     It calls handle_event(Event, State) for each handler.
**** to remove handlers: gen_event:delete_handler
     gen_event:delete_handler( Manager, Handler, Args)
     Calls `Handler:terminate( Args, State )`.
**** to stop
     https://erlang.org/doc/design_principles/events.html#stopping
     I didn't entirely get it.
*** callbacks the user must define
**** init( Args ) -> {ok, State}
**** handle_event( Event, State ) -> {ok,NewState}
**** handle_info(Info, StateName, StateData) -> {ok, NewState}
**** code_change(OldVsn, State, Extra) -> {ok, NewState}
** supervisors
*** Supervisors (re)start, stop, and monitor their children.
*** Children are stopped in reverse order.
    "The child processes are started in the order specified by [the "child specification"], and terminated in the reversed order."
*** a complete example (very short)
    -module(ch_sup).
    -behaviour(supervisor).

    -export([start_link/0]).
    -export([init/1]).

    start_link() ->
        supervisor:start_link(ch_sup, []).

    init(_Args) ->
        SupFlags = #{strategy => one_for_one,
                 intensity => 1,
                 period => 5},
        ChildSpecs = [#{id => ch3,
                        start => {ch3, start_link, []},
                        restart => permanent,
                        shutdown => brutal_kill,
                        type => worker,
                        modules => [cg3]}],
        {ok, {SupFlags, ChildSpecs}}.
*** starting it
**** `supervisor:start_link(Module,Args)` calls `Module:init(Args)`.
**** to start it with a registered name
     supervisor:start_link({local, Name}, Module, Args)
     supervisor:start_link({global, Name}, Module, Args)
**** start_link is synchronous.
     Returns only after all child processes have started.
*** callback `init(Args)` ->  {ok, {SupFlags, ChildSpecs}}
*** supervisor options
**** an incomplete overview
     sup_flags() =
       #{ strategy => strategy(),           % optional restart strategy
          intensity => non_neg_integer(),   % optional
          period => pos_integer(),          % optional
          auto_shutdown => auto_shutdown()} % optional
     where
     strategy() = one_for_all  % If anything terminates, all are terminated,
                               % and all restarted.
		| one_for_one  % *The default*.
                               % If a child process terminates,
                               % only that process is restarted.
		| rest_for_one % If anything terminates,
                               % everything *after* it is terminated too,
			       % and then all of those are restarted.
		| simple_one_for_one
     auto_shutdown() = never   % *The default*.
                               % Significant children are rejected.
                     | any_significant
                     | all_significant
**** specifying intensity
***** SupFlags = #{intensity => MaxR, period => MaxT, ...}
***** what that does
     """
     If more than MaxR number of restarts occur in the last MaxT seconds,
     the supervisor terminates all the child processes and then itself.
     The termination reason for the supervisor itself in that case will be shutdown.

     When the supervisor terminates, then the next higher-level supervisor takes
     some action. It either restarts the terminated supervisor or terminates itself.

     The intention of the restart mechanism is to prevent a situation where a
     process repeatedly dies for the same reason, only to be restarted again.

     The keys intensity and period are optional in the supervisor flags map. If they
     are not given, they default to 1 and 5, respectively.
     """
***** "Tuning it" is an art.
      which I ignored.
      https://erlang.org/doc/design_principles/sup_princ.html#maximum-restart-intensity
**** automatic shutdown
***** Terminates the supervisor when "significant children" terminate.
***** Only happens if the child stops itself -- not when the supervisor does.
***** PITFALL: Only available from OTP 24 onward.
*** child specifications
**** an overview
     child_spec() =
       #{ id :: term,             % mandatory
          start :: { M :: module, % mandatory
                     F :: atom,
                     A :: [term]},
          restart :: permanent  % *The default*. Always restarted.
                   | transient  % Never restarted.
                   | temporary, % Restarted only if terminated abnormally.
          significant :: bool   % Not available for permanent children.
          shutdown :: brutal_kill % Uses exit(Child, kill).
                    | timeout, % Calls `exit(Child, shutdown).
                               % Waits for a response.
                               % After timeout, calls `exit(Child, kill)`.
			       % Defaults to 5s for workers,
			       %             infinity for supervisors.
          type :: worker % *The default.*
	           % `infinity` shutdown time is dangerous in this case.
                | supervisor % Shutdown timeout should then be `infinity`.
          modules :: ?? }
**** The supervisor starts each child with `apply(M, F, A)`.
     It should result in a call to one of these, or something like it:
       supervisor:start_link
       gen_server:start_link
       gen_statem:start_link
       gen_event:start_link
*** adding children on the fly
**** syntax
     supervisor:start_child(
       Supervisor_PID, ChildSpec)
**** PITFALL: Lost if the supervisor dies and restarts.
*** Supervisors can terminate their children.
    supervisor:terminate_child( Sup, Child_Id )
    This does not trigger automatic shutdown.
*** Delete the spec for a stopped child.
    supervisor:delete_child(Sup, Child_Id)
**** PITFALL: This deletion is undone if the supervisor is restarted.
***** TODO Isn't that bad?
*** SKIPPED: The simple_one_for_one strategy.
    A supervisor with restart strategy simple_one_for_one is a simplified one_for_one supervisor, where all child processes are dynamically added instances of the same process.
*** PITFALL, SKIPPED: Automatic shutdown > manual shutdown.
    https://erlang.org/doc/design_principles/sup_princ.html#stopping
* notes from LYSE, distrusted
** Show and delete messages to the repl with flush/0.
   :PROPERTIES:
   :ID:       0dfa99f9-7d57-4d9d-b664-728d6b916ea8
   :END:
** Coordinating process errors.
*** TODO Much of this chapter I did not understand.
    :PROPERTIES:
    :ID:       4513bc08-e581-4009-b992-7b1e3c903c9a
    :END:
    https://learnyousomeerlang.com/errors-and-processes
*** "Monitors" are directed, stackable links.
**** TODO what does "stackable" mean?
     I suspect it means there can be more than one link from A to B.
     But part of LYSE suggested it means that,
     if A is linked to B which is linked to C,
     unlinking A from B leaves the link from B to C intact.
**** TODO I didn't fully understand the Monitors section.
     https://learnyousomeerlang.com/errors-and-processes#monitors
**** Two processes can both monitor each other.
     If either fails, the other will be notified, but not taken down.
**** Create monitor links with erlang:monitor/2 :: Atom -> PID -> IO (monitor reference).
***** PITFALL: The first arg is always the atom `process`.
**** When a process goes down, its monitor receives a message of the form
     {'DOWN', MonitorReference, process, Pid, Reason}
***** TODO is that the only kind of message a monitor relationship generates?
      :PROPERTIES:
      :ID:       cac7b800-f386-47e0-9cde-0e7cba38c718
      :END:
**** spawn_monitor/1-3 are atomic, like spawn_link/1-3.
     They return a pair:
       {Pid of new process, Ref of new monitor relationship}
**** Use `erlang:demonitor/1` to end a monitoring relationship.
*** Attach a "Ref", not just a Pid, to any message that requires a reply.
    That way, if A sends to B and receives a reply,
    and B's reply includes the same Ref,
    then A knows what B is talking about.
*** It's common to export `start` and `start_link` functions.
    They correspond to spawn and spawn_link.
    They permit the programmer to hide implementation details from the user.
*** checking if a process exists
**** example
     https://learnyousomeerlang.com/designing-a-concurrent-application#understanding-the-problem
     cancel(Pid) ->
       %% Monitor in case the process is already dead
       Ref = erlang:monitor(process, Pid),
       Pid ! {self(), Ref, cancel}, % Tell it to stop.
       receive
         {Ref, ok} -> % It was already down.
           erlang:demonitor(
             Ref,
             [flush]), % "purge the DOWN message if it was sent before
                       %  we had the time to demonitor"
           ok;
         {'DOWN', Ref, process, Pid, _Reason} ->
           ok
       end.
**** TODO does this mean a monitor receives a "DOWN" message even if it's created after the process being watched goes down?
**** TODO Why flush a monitoring function that's about to end anyway?
     Is that because it shares a mailbox with whatever called it?
*** The reference to a monitor can be a good key for a store of clients.
    Ref = erlang:monitor(process, Client),
    NewClients =
      orddict:store(
        Ref, % "the only other time we'll need to fetch the client ID will be if we receive [EXIT from the monitor], which will contain" REF. https://learnyousomeerlang.com/designing-a-concurrent-application#understanding-the-problem
        Client,
        S#state.clients), % the map to modify
** The OTP library
*** gen_server: the Generic Server module|behavior
    https://learnyousomeerlang.com/clients-and-servers#callback-to-the-future
**** some "callbacks": functions the user must define *and export*
     If they aren't exported, gen_server can't use them, I guess.
***** init/1
****** called by gen_server:start and gen_server:start_link
****** messages it can return
******* {ok, State}
******* {ok, State, TimeOut}
        "The TimeOut variable is meant to be added to the tuple whenever you need a deadline before which you expect the server to receive a message. If no message is received before the deadline, a special one (the atom timeout) is sent to the server, which should be handled with handle_info/2 (more on this later.)"
******* {ok, State, hibernate}
        "if you do expect the process to take a long time before getting a reply and are worried about memory, you can add the hibernate atom to the tuple. Hibernation basically reduces the size of the process' state until it gets a message, at the cost of some processing power. If you are in doubt about using hibernation, you probably don't need it."
******* {stop, Reason}
        When initialization fails.
******* ignore
****** whatever calls init/1 blocks until it returns
       It is waiting for a `ready` message
       from the `gen_server` module.
***** handle_call :: (Request, From, State) -> <response>
      :PROPERTIES:
      :ID:       bc1f3d25-47cb-4210-a43c-8787f3e744e3
      :END:
****** called by gen_server:call
****** for synchronous messaging
****** valid response formats
******* {reply,Reply,NewState}
******* {reply,Reply,NewState,Timeout}
******* {reply,Reply,NewState,hibernate}
******* {noreply,NewState}
******* {noreply,NewState,Timeout}
******* {noreply,NewState,hibernate}
******* {stop,Reason,Reply,NewState}
******* {stop,Reason,NewState}
****** how the terms in those messages work
******* `TimeOut` and `hibernate` work like in init/1.
******* `Reply` is sent back to whoever asked for it.
******* `noreply` tells the server not to reply.
        :PROPERTIES:
        :ID:       26114ed6-ebd8-4ccd-a525-0d3fc7aba7da
        :END:
        "you're taking care of sending the reply back yourself."
        Do so with gen_server:reply/2.
***** handle_cast :: (Message, State) -> <response>
      :PROPERTIES:
      :ID:       ce8cbd61-4465-4452-ae19-753b6a227ddd
      :END:
****** called by gen_server:cast
****** for asynchronous messaging
****** much like [[id:bc1f3d25-47cb-4210-a43c-8787f3e744e3][handle_call]]
****** valid response formats
       {noreply,NewState}
       {noreply,NewState,Timeout}
       {noreply,NewState,hibernate}
       {stop,Reason,NewState}
***** handle_info/2 : handle messages outside the interface
****** a quote
       "similar to [[id:ce8cbd61-4465-4452-ae19-753b6a227ddd][handle_cast/2]] and in fact returns the same tuples. The difference is that this callback is only there for messages that were sent directly with the ! operator and special ones like init/1's timeout, monitors' notifications and 'EXIT' signals."
****** Valid response formats include
       but might not be limited to
******* {noreply, Cats}
****** But remember they can do IO too.
       A natural implementation would be to log the unexpected messages.
***** terminate/2 :: (Reason, State) -> <dunno>
****** called in response to `{stop, ...}` tuples
       {stop, Reason, NewState}
       {stop, Reason, Reply, NewState}
****** valid Reason values
******* are these
        normal
        shutdown
        {shutdown, Term}
******* if Reason fits none of those patterns, logging happens
        "If any reason other than normal, shutdown or {shutdown, Term} is used when terminate/2 is called, the OTP framework will see this as a failure and start logging a bunch of stuff here and there for you."
****** might be called if its parent (spawner) dies
       That happens if and only if
       the gen_server is trapping exits.
****** is like the opposite of init/1
****** return value doesn't matter
       "the code stops executing after it's been called"
***** code_change/3 :: (PrevVersion, State, Extra) -> {ok, NewState}
****** valid PreviousVersion values
       either the version term itself in the case of an upgrade
       or {down, Version} in the case of a downgrade
****** State is the current server's state
****** Extra is advanced stuff.
**** some functions a user is likely to define
***** offload `start_link` to `gen_server`
      start_link () -> % returns {ok,Pid}
        gen_server:start_link(
          % optional fourth parameter in first (this) position:
          % name to register server under
          ?MODULE,  % where the callbacks are
          [],       % parameters for init/1
          []).    % debugging options
***** gen_server:call :: Pid -> Message -> _ -> IO ()
      The Pid is, I imagine, who sent the message.
      The optional (i.e. can be missing entirely)
      third argument is a timeout, defaulting to 5 seconds.
**** gen_server:reply/2
     Useful when you'd like to [[id:26114ed6-ebd8-4ccd-a525-0d3fc7aba7da][handle the reply yourself]],
     rather than using the server.
**** TODO What do I have to export?
     c.f. ~/code/concurrent-langs/erlang/kitty/v3-otp/kitty_gen_server.erl
     If I export_all it works.
     If I try to export only the interface, it doesn't.
*** gen_fsm: the Generic Finite State Machine module|behavior
    https://learnyousomeerlang.com/finite-state-machines
**** looks like a digraph
**** callback the user must define
***** in all of these, `stop`, Timeout and `hibernate` work the same as in `gen_server`.
***** init/1
****** acceptable return values
       {ok, StateName, Data}
       {ok, StateName, Data, Timeout}
       {ok, StateName, Data, hibernate}
       {stop, Reason}
****** the `StateName` atom indicates the next callback to use
***** StateName/2-3
      For each state defined in `init`,
      there should be at least one function of the same name.
      taking 2 arguments if async, 3 if sync.
****** For a given StateName, *either or both* StateName/2 and StateName/3 can be defined.
****** StateName/2 :: EventMessage -> StateData -> _
******* valid return values
        {next_state, NextStateName, NewStateData}
        {next_state, NextStateName, NewStateData, Timeout}
        {next_state, NextStateName, NewStateData, hibernate}
        {stop, Reason, NewStateData}
****** StateName/3 :: EventMessage -> From -> StateData -> _
******* valid return values
       {reply, Reply, NextStateName, NewStateData}
       {reply, Reply, NextStateName, NewStateData, Timeout}
       {reply, Reply, NextStateName, NewStateData, hibernate}

       {next_state, NextStateName, NewStateData}
       {next_state, NextStateName, NewStateData, Timeout}
       {next_state, NextStateName, NewStateData, hibernate}

       {stop, Reason, Reply, NewStateData}
       {stop, Reason, NewStateData}
***** handle_event/3 :: EventMessage -> StateName -> StateData -> _
****** for events that are handled the same from every state
       (So it seems strange that StateName is an argument ...)
****** is for async events, I think
***** handle_sync_event/4 ::
****** for synchronous global events
****** "takes the same parameters and returns the same kind of tuples as StateName/3."
***** code_change/4
****** like the same function in gen_servers
****** input: (OldVersion, StateName, Data, Extra)
****** output: {ok, NextStateName, NewStateData}
***** terminate/3
**** sending (async, sync) events to (some, every) state -> four functions
***** send_event/2
      Asynchronous events aimed at any StateName/2 function
***** sync_send_event/2-3
      "synchronous events to be picked up by [any?] StateName/3"
***** send_all_state_event/2 and sync_send_all_state_event/2-3
      "Equivalent" to the previous two, but for "global" events.
****** TODO "global" events?
**** [[id:306ceafe-96fd-4076-87e3-81a617b0d99c][synchronous vs. asynchronous communication: when to prefer which]]
**** [[id:b0957f0c-b592-4906-be93-638476a45b20][designing asynchronous protocols]]
*** gen_event: the Generic Events module|behavior
    https://learnyousomeerlang.com/event-handlers
**** "event handlers run in the same process as their manager"
**** callbacks the user must define
***** init/1
      takes a list of arguments and returns {ok, State}.
***** terminate/2
***** handle_event :: (Event, State) -> _
****** asynchronous
****** acceptable return values
******* {ok, NewState}
        replies to nobody
******* {ok, NewState, hibernate}
        puts the event manager itself into hibernation until the next event
******* remove_handler
        "drops the handler from the manager"
        Good for when the handler is finished.
******* {swap_handler, Args1, NewState, NewHandler, Args2}
        Rarely used.
        Calls these in serial:
          CurrentHandler:terminate(Args1, NewState)
          NewHandler:init(Args2, ResultFromTerminate)
****** triggered by `gen_event:notify/2`
***** handle_call
****** acceptable return values
       {ok, Reply, NewState}
       {ok, Reply, NewState, hibernate}
       {remove_handler, Reply}
       {swap_handler, Reply, Args1, NewState, Handler2, Args2}
****** "like gen_server:handle_call`
       Does that mean its inputs are (Request, From, State)?
****** triggered by `gen_event:call/3-4`
***** handle_info/2
      For unexpected messages.
***** code_change :: (OldVsn, State, Extra) -> _
****** like in gen_server
****** applies to each event handler individually
****** can return {ok, NewState}
       and maybe other stuff
**** functions it defines
***** gen_event:notify/2 :: async
***** gen_event:sync_notify/2 :: sync
      "returns once all event handlers have seen and treated the new message. Until then, the event manager will keep blocking the calling process by not replying."

** Supervisors
*** Can restart dead processes.
*** A DIY supervisor.
    -module(sup). % "supervisor"
    -export(
       [ start/2
       , start_link/2
       , init/1
       , loop/1]).

    start(Mod,Args) ->
      spawn(
        ?MODULE,
        init,
        [ { Mod % Any module with a start_link function.
          , Args % Any tuple matching Mod:start_link's arity.
          } ] ).

    start_link(Mod,Args) ->
      spawn_link( ?MODULE, init, [{Mod, Args}] ).

    init({Mod,Args}) ->
      process_flag(trap_exit, true),
      loop({Mod,start_link,Args}).

    loop({M,F,A}) ->
      Pid = apply(M,F,A),
      receive
        {'EXIT', _From, shutdown} ->
          exit(shutdown); % will kill the child too
        {'EXIT', Pid, Reason} ->
          io:format(
        "Process ~p exited for reason ~p~n",
        [Pid,Reason]),
          loop({M,F,A})
      end.
