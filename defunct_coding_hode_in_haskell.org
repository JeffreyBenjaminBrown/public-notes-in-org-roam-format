:PROPERTIES:
:ID:       2b735c4f-b4d9-4d7d-9155-b650d90a2c4a
:END:
#+title: defunct : coding Hode in Haskell
* backup the data repo(s)
* TODO critical
** TODO document
*** TODO resume doc QA at
ui.md # Keyboard commands
*** TODO better intro
Explain that to use it, you don't need to know any Hash except how to use #.
The rest is just for doing fancy searches.
*** TODO align the interactive help with the docs/ folder
*** TODO ensure orphans are covered
**** # operator precedence
We can vary the number of hash symbols attached to a separator to indicate how high a relationship is.
This is optional, but it makes things easier to read.
For instance, the previous relationship could be written without parentheses as
`Mary ##knows Bill #likes Sue`.

When you're writing data into a `Rslt` you can use either style,
parentheses or multiple hashmarks, to structure an expression.
You can even mix them both in the same expression.
*** TODO add hyperlinks
Could stick in the markdown easily.
Not so easy in the app.
*** TODO IMPORTANT documentation: order of topics
**** TODO Hash ops:
Important because if set ops are introduced before /eval,
either it's confusing or they look useless.
***** fundamental: #, /_, /t, /ts, /@
***** set ops
***** subexpr matching
  /member: with top-level sub-expr
  /involves: with sub-expr at depth
  /eval: find expr, return subexpr
  /it: id subexpr in expr
  /it=: id & limit subexpr in expr
  /map: map roles to exprs
***** order & transitivity
  reach, transLeft, transRight
*** TODO verify hyperlinks
*** TODO verify docs/ coverage
*** maybe the # parser should be treated specially
and the "slashPrefix" field dropped.
*** ? these features
are already in the interactive help
select ViewExpr (M-X)
nudging (M-E, M-D)
deleting buffers
** TODO ? multi-line expressions
** TODO check for cycles when a tplt is declared transitive
Check for cycles non-locally --
that is, with reference to no particular point in the cycle.
* TODO critical but can wait until after beta release
** TODO shrink memory footprint, git-compatible, keep timestamps
Aggregate data into fewer files.
After each node ID, keep its creation date and its last modified date.
That way a little awk or something can find me the diff history of that node,
without bringinng the history of everything else with it.
** TODO batch add
/a (patience | humor) #is-a (virtue | skill)
** TODO save should first delete all .rslt files
** permit scrolling
*** in the main help window
*** in the history window
*** if I want a scrollbar
 Maybe Brick offers one as part of a viewport.
 If not, could instead indicate, e.g., "Item 3 of 5" near menus.
** modes and keymap
*** help mode: make the submode menu optional
    If there's only one choice in that layer, hide it.
*** implement new commands
M-w e - <new> Show error "buffer". (Why is this not a proper buffer?)
M-w r - <new> Toggle reassurance window.
** TODO the obstructive subexpression problem
*** EASY: the "don't show X in maybe X" problem
Just add some more indicators to _columnHExprs:
  not, maybe, and warning
*** after using the app more, maybe consider the more general problem
** TODO change: can insertHosts_atFocus when they're already there
** TODO folding indicator
Visually indicate whether a node with descendents is folded.
Or at least, upon inserting contents, unfold.
** TODO ? compress binary groups
** manual update
* TODO unsorted
** TODO BUG: does the ui insert "\n" at the end of user commands?
 In open code, this always works:
   MP.parse _pHashExpr "" "a # /_ "
 But in the ui, "/f a # /_" generates a parse error
   if nonPrefix is not checking for \n.
*** changing the definition of nonPrefix "fixes" it
 but undoes the reasons that I made those changes.
 Namely, set it back to `... <* notFollowedBy alphaNumChar`
*** TODO learn how lexing works
 The problem is that I've absorbed the detection of parens and quotation marks
 (and space?) into the parsers for individual terms.
** TODO interactive help: scrolling in the main window doesn't work
** TODO restore: there used to be a way to switch to the error buffer
It was `M-e` or `M-E`.
** TODO ? use BiMap to associate Addrs and Exprs
** ordering
*** TODO ? BUG : when removing from an order, connect any gaps created
(The relevant function is removeSelections_fromSortedRegion.)
So far it disconnects the to-be-removed from the still sorted,
and mutually disconnects everything in the to-be-removed.
*** TODO BUG in sort
**** a way to trigger it
 /a a # b # c # d
 /f a # b # c # d
 <view members>
 /a (a # c) # (c # b)
 /sr (/t /_ "" /_)
**** the problem
 kahnSort deletes expressions from a copy of the graph.
 Deletion something that's a member of other things is not permitted.
**** the solution, I think
 is to create and use an "unsafeDelete" which does not check for membership in superexpressions.
 I think this works because in the course of sorting we never need to find anything's subexpressions.
*** TODO ? a function to "iron" an order into place
A graph can in general have multiple ways to be topologically sorted.
Therefore, when the user sees a set of ordered expressions,
and A > B on screen,
it could be that A is not truly > B. (It can't, however, be that A < B.)
To "iron" a subset of an order would be to create a chain through them all,
such that the order in which they appear on screen is indeed the only reasonable order among them.
*** display
**** the highlight should not affect the columns, only the payload
**** more expressive sort-colors
***** there are currently these two categories
Involved in the relationship -- even if its partner is not in this list.
Not involved in the relationship.
***** There should be these four categories.
****** with no transitive relation (TR) to the others
 black, last
****** with some TR to the others, but not *this* TR
 that is, not related to anything else in the list by the TR that currently orders the list
****** related to others in the list by the TR ordering the list
****** related to others *not* in the list by the TR ordering the list
**** by default, sort by the first applicable sort criterion
 in each group of search results -- top-level or otherwise.
 Change ExprTree.insertSearchResults_atFocus
   based on RunParsed.runParsedCommand
**** indicate the sort applied to each view-fork
e.g. in parens, following the name of the fork
or with a typed-in command that shows it in the reassurance window.
**** DONE , right? keyboard command to change the sort on a group
***** later, a "sort program" buffer
Specific to a given VExpr, applied to its children.
Shows every TR, and a checkbox next to the one curently ordering the list.
The checkbox can be moved.
*** ? needs a closure algorithm
Suppose [a,b,c] are to be shown, and a > b, and c > d.
None of them are isolated from the closure of (>),
but among [a,b,c], c is isolated.
It should be shown in the unsorted group.
*** ? compromise: don't consider non-local connections
** TODO rewrite the PTree class
*** the new type
It can be like Data.Tree.Zipper, but using PointedLists (Plists).
The focus and its peers are represented as a PList of PTrees.
The ancestors are represented like in Data.Tree.Zipper:
each is a (reversed [PTree a]) a [PTree a].
Moving sideways is just a PList op.
Moving up or down requires converting one level between the PList and ancestor representations.
*** TODO first survey how I use it
It's only used in Hode.UI.
Potentially tricky:
  building a tree from the top while knowing where the focus is.
  Optics (refer to the PointedList implementation).
** TODO establish an informal schema
*** TODO Is (#maybe _) different from (#question _)?
(#question _) seems more general -- it permits non-boolean members.
*** AMR might be useful
 https://github.com/nschneid/amr-tutorial/raw/master/slides/AMR-TUTORIAL-FULL.pdf
 (in my Downloads/ folder)
** TODO optic ideas
*** Tree has an Ix class.
 I could write one for the Rslt, which might make following paths easier.
*** TODO are there other getters I should rewrite as folds?

** TODO is PTree focus buggy?
 When I run `st <- ui`, look through a small view-tree,
 and then exit and study `st`, I find many nodes for which `pTreeHasFocus`
 is `True`. This seems to contradict a comment in PTree.Initial, that
 "If it has focus, none of its children should."
** TODO unify cyclesInvolving, connections, and things yet to write
 something yet to write: like connections or cyclesInvolving, but it only returns the first thing it finds, rather than all of them.

 cyclesInvolving returns a set of cycles (whole paths), which is inefficient in its only current use context, the CycleBuffer. It should only return one.

 reachable gives everything reachable from a set of origins; the target set is unrestricted. It doesn't give the path, just the destination.
* TODO pressing
** TODO tests for the UI
*** St could be Eq and Ord
if I made (probably orphan) instances for Brick.Widgets.Edit.Editor
** TODO error window: Why is it treated differently?
** TODO reading and navigation are slow
*** would help: hide in context
in the context of golf, any phrase ending in "of golf"
can be omitted
**** how not to repeat a context?
 My data currently includes (fake addresses):
   @1: extend ##o columns #of hode
   @2: #to @1 #do ...

 As it stands that's fine,
 but I would like to create a Hode to-do list:
   @3: #for hode #do @1
 i.e.
   @3: #for hode #do (extend ##o columns #of hode)
*** would help: synonyms
*** would help: don't group single items
*** might help ? better columns
Some as counts, some otherwise.
*** might help ? distinguish "of interest" expressions
** TODO templates for sets of arbitrary size
** count more stuff in the left column(s)
*** ? use hMatches
*** let the user add HExprs to _columnHExprs
*** let each HExpr column be given a title
*** let each buffer keep its own list of HExprs
*** indicate matches ala chmod
A single decimal (hex) digit can indicate whether an `Expr`
matches up to 3 (4) separate `HExpr`s.
** TODO filters, throughout the view-Porest
not just its top level
* TODO easy
** TODO rename "command window" -> "minibuffer"
** TODO use HasCallStack to mark partial functions.
 https://www.tweag.io/posts/2020-04-16-exceptions-in-haskell.html
** TODO don't print zeroes in the columns
** TODO insertion list
*** plan
**** data St = ...
+  , _insertionBuffer :: Buffer
**** initially, just add the final result of insertions
**** then refactor insertion so it returns the full history of added things
*** complications
(1) inserting a compound expression inserts subexpressions
(2) don't record insertion if it already existedx
** TODO the color "white text on black background"
** TODO new in GHC 8.10: :instances
Given a type, shows its classes.
** TODO shortcut to empty the command window
was implemented already once
** TODO merge two nodes
*** why
e.g. because (and why can this happen?)
two identical templates exist at different addresses.

For an example of that error,
see jbb/ until (but not after)
commit 15201a6561b4181695f72bcb176136f43c94f853
*** how
If they are not identical, one of them is the "survivor".
They can be templates, if they have the same arity.
** TODO upon save, delete unused phrases and templates
unless maybe it's a long phrase
PITFALL: But don't delete the empty string.
         Or maybe the need for the empty string is obsolete?
* TODO user-friendliness
** TODO crawling within an Expr
up|down to enclosing keyword (/hash, etc)
up|down to nearest higher binop (#, |, etc)
up|down, multipurpose
  this kind goes to either of the two previous kinds of things
left|right in same level
** TODO a regex index
** TODO If there's a cycle, announce it everywhere
at the top of every window except the Error window.
** TODO edit a PTree
*** Annotate things.
*** delete parent from any PTree
and move children up to where it was
** TODO wrapping is buggy
*** example
For instance, the display of this (at address 153 in jbb/)
   ###re ##solve tmux #has-problem sometimes the status bar is cluttered ##by keep only window names ###note-that status-right #can put any label at the right of the status bar, e.g. the current time.
includes a 121-character-long line.
*** todo ? distance to wrap should shrink with columns, indentation
*** todo ? temp fix: allow user to change wrap length
** TODO ? offer to delete orphaned nodes
If a member of something deleted is not remember of anything else, ask whether to delete it, too -- and recurse.
** TODO copy to clipboard: buggy on Nix
On Nix it represents newlines the wrong way.
** TODO shortcut: copy address
** TODO ? back-references for searches encoded as Exprs
When a new node is added that matches an extant search,
the search will find it, but (without further work)
it will not find the search as a neighbor.
** TODO ? wart: monodirectionality in `reachable`
It can accept multiple `Tplt`s to search along,
but only a single `SearchDir`.
** safer open and save
To write, first run `git status`.
If anything is modified, ask "are you sure? Your repo has uncommitted changes; saving this data might clobber them."

If it's not a repo, ask, "Are you sure you don't want to turn that data into a Git repo first?"
** document the precedence order of the language
and mention that you can use parens liberally to make it more obvious
** show path to here
(Not a big deal because the cursor path is remembered.)
Add a toggleable window above the Results window.
* TODO HExpr: extend HMember and HInvolves
** implement HMember-Star
which searches to arbitrary depth
** Permit them to be inside `HEval`s
Involves does not play nicely with pathsToIts.
Even the Involves that only goes 1 layer deep is confusing.
Once it is implemented, Paths needs to not be integers lists;
they will have to be lists of (Integer | Wildcard),
where a Wildcard stands for "any number could go here".
* PIFALLs | warts
** TODO searching for a Tplt with empty-string separators
One needs to represent the empty separator as \"\", as in this:
   Right r = nInserts (mkRslt mempty) [ "0 # 1", "1 # 2" ]
   t = nFind r "/t /_ \"\" /_"
** in Qseq
*** PITFALL: varTestlike ForSomes do not store what they find in the Subst
 unlike testlike and findlike queries
*** PITFALL: Each mapping in a CondElts can be represented many ways, depending on whether they key is included.
 The current idiom is to leave the key out. But -- you could describe a CondElts this way:
  x=1 if (a=1    ) or (b=1    )
 or equivalently, this way:
  x=1 if (a=1,x=1) or (b=1,x=1)
 or this way:
  x=1 if (a=1    ) or (b=1,x=1)
 etc.
*** PITFALL: The empty set is nonsense in a CondElts
 type CondElts = Map Elt (Set Subst)
   -- ^ Uses `Set` because multiple `Subst`s might obtain the same `Elt`.
   -- PITFALL: If Elt is possible without any other bindings, then
   -- the `Set` should include `M.empty`. If the `Set` is `S.empty`,
   -- it is as if that `Elt` is not in the `Map`.
*** PITFALL: Don't let keys collide in a CondElts
 If a=1 or a=2 can both lead to b=1, it's tempting to write this:
   (p :: Possible) =
     M.fromList [ (a, ...)
                , (b, M.fromList [ (1, S.singleton $ M.singleton a 1)
                                 , (1, S.singleton $ M.singleton a 2) ] ) ]
 when it ought to be this:
   (p :: Possible) =
     M.fromList [ (a, ...)
                , (b, M.fromList [ (1, S.fromList [ M.singleton a 1
                                                  , M.singleton a 2 ] ) ] ) ]
*** PITFALL : mkVTestIO' : naming error => silent failure
 see the comment leading its definition
* might come back to haunt me
** pExprIsSpecific should address PDiff, PAnd, POr
*** where it is used
 In pRelToHExpr, only specific things can be converted.
 In pMapToHMap, only specific things are retained.
*** how to do it, I think
 if anything in a POr is not specific, then it is not
 if anything in a PAnd is specific, then it is
 if both parts of a Diff are specific, then it is
   Theoretically, the part being subtracted could be vague.
   But that's not how it's implemented -- both parts have to be found,
   then the one is subtracted from the other.
* coder-friendliness
** to include arity in the a node's type
see digraphs-with-text/gadt.hs
** TODO simplify result of nPExpr
e.g. if q = "/trr 1 #< (/it= 0 | 2)", then
nPExpr q = Right ( PRel $ PNonRel $ ...
** TODO ? separate State and UIState, and use State in NoUI
type ColumnProps = Map HExpr Int
data OtherProps = OtherProps {
  _folded :: Bool -- ^ whether the ViewExprNode's children are hidden
  } deriving (Show, Eq, Ord)
data St = St {
    _searchBuffers          :: Maybe (Porest Buffer)
  , _columnHExprs           :: [HExpr]
  , _appRslt                :: Rslt
  }
** wart: ifLefts and LeftStrings
*** could be replaced with Data.Validation
which comes with toEither and fromEither
https://www.reddit.com/r/haskellquestions/comments/d4f6px/class_should_apply_to_a_functor_only_when_its/
*** LeftStrings could be more polymorphic
https://www.reddit.com/r/haskellquestions/comments/d4f6px/class_should_apply_to_a_functor_only_when_its/
** wart ? HExpr and PExpr are complex and nearly isomorphic
** wart: RsltViewTree is not natural
*** the root
The root is supposed to only be a Query,
but that is permitted elsewhere.
The root information is(will be) duplicated by the buffer.
*** the alternation is not enforced
It should be that each ViewResult can only have a Host or Members as a child,
and vice-versa.
* _ for insertion _
