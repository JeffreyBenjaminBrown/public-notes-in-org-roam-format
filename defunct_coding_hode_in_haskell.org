:PROPERTIES:
:ID:       2b735c4f-b4d9-4d7d-9155-b650d90a2c4a
:END:
#+title: defunct : coding Hode in Haskell
* backup the data repo(s)
* TODO critical
** TODO document
*** TODO resume doc QA at
ui.md # Keyboard commands
*** TODO better intro
Explain that to use it, you don't need to know any Hash except how to use #.
The rest is just for doing fancy searches.
*** TODO align the interactive help with the docs/ folder
*** TODO ensure orphans are covered
**** # operator precedence
We can vary the number of hash symbols attached to a separator to indicate how high a relationship is.
This is optional, but it makes things easier to read.
For instance, the previous relationship could be written without parentheses as
`Mary ##knows Bill #likes Sue`.

When you're writing data into a `Rslt` you can use either style,
parentheses or multiple hashmarks, to structure an expression.
You can even mix them both in the same expression.
*** TODO add hyperlinks
Could stick in the markdown easily.
Not so easy in the app.
*** TODO IMPORTANT documentation: order of topics
**** TODO Hash ops:
Important because if set ops are introduced before /eval,
either it's confusing or they look useless.
***** fundamental: #, /_, /t, /ts, /@
***** set ops
***** subexpr matching
  /member: with top-level sub-expr
  /involves: with sub-expr at depth
  /eval: find expr, return subexpr
  /it: id subexpr in expr
  /it=: id & limit subexpr in expr
  /map: map roles to exprs
***** order & transitivity
  reach, transLeft, transRight
*** TODO verify hyperlinks
*** TODO verify docs/ coverage
*** maybe the # parser should be treated specially
and the "slashPrefix" field dropped.
*** ? these features
are already in the interactive help
select ViewExpr (M-X)
nudging (M-E, M-D)
deleting buffers
** TODO ? multi-line expressions
** TODO check for cycles when a tplt is declared transitive
Check for cycles non-locally --
that is, with reference to no particular point in the cycle.
* TODO critical but can wait until after beta release
** TODO shrink memory footprint, git-compatible, keep timestamps
Aggregate data into fewer files.
After each node ID, keep its creation date and its last modified date.
That way a little awk or something can find me the diff history of that node,
without bringinng the history of everything else with it.
** TODO batch add
/a (patience | humor) #is-a (virtue | skill)
** TODO save should first delete all .rslt files
** permit scrolling
*** in the main help window
*** in the history window
*** if I want a scrollbar
 Maybe Brick offers one as part of a viewport.
 If not, could instead indicate, e.g., "Item 3 of 5" near menus.
** modes and keymap
*** help mode: make the submode menu optional
    If there's only one choice in that layer, hide it.
*** implement new commands
M-w e - <new> Show error "buffer". (Why is this not a proper buffer?)
M-w r - <new> Toggle reassurance window.
** TODO the obstructive subexpression problem
*** EASY: the "don't show X in maybe X" problem
Just add some more indicators to _columnHExprs:
  not, maybe, and warning
*** after using the app more, maybe consider the more general problem
** TODO change: can insertHosts_atFocus when they're already there
** TODO folding indicator
Visually indicate whether a node with descendents is folded.
Or at least, upon inserting contents, unfold.
** TODO ? compress binary groups
** manual update
* TODO unsorted
** TODO BUG: does the ui insert "\n" at the end of user commands?
 In open code, this always works:
   MP.parse _pHashExpr "" "a # /_ "
 But in the ui, "/f a # /_" generates a parse error
   if nonPrefix is not checking for \n.
*** changing the definition of nonPrefix "fixes" it
 but undoes the reasons that I made those changes.
 Namely, set it back to `... <* notFollowedBy alphaNumChar`
*** TODO learn how lexing works
 The problem is that I've absorbed the detection of parens and quotation marks
 (and space?) into the parsers for individual terms.
** TODO interactive help: scrolling in the main window doesn't work
** TODO restore: there used to be a way to switch to the error buffer
It was `M-e` or `M-E`.
** TODO ? use BiMap to associate Addrs and Exprs
** ordering
*** TODO ? BUG : when removing from an order, connect any gaps created
(The relevant function is removeSelections_fromSortedRegion.)
So far it disconnects the to-be-removed from the still sorted,
and mutually disconnects everything in the to-be-removed.
*** TODO BUG in sort
**** a way to trigger it
 /a a # b # c # d
 /f a # b # c # d
 <view members>
 /a (a # c) # (c # b)
 /sr (/t /_ "" /_)
**** the problem
 kahnSort deletes expressions from a copy of the graph.
 Deletion something that's a member of other things is not permitted.
**** the solution, I think
 is to create and use an "unsafeDelete" which does not check for membership in superexpressions.
 I think this works because in the course of sorting we never need to find anything's subexpressions.
*** TODO ? a function to "iron" an order into place
A graph can in general have multiple ways to be topologically sorted.
Therefore, when the user sees a set of ordered expressions,
and A > B on screen,
it could be that A is not truly > B. (It can't, however, be that A < B.)
To "iron" a subset of an order would be to create a chain through them all,
such that the order in which they appear on screen is indeed the only reasonable order among them.
*** display
**** the highlight should not affect the columns, only the payload
**** more expressive sort-colors
***** there are currently these two categories
Involved in the relationship -- even if its partner is not in this list.
Not involved in the relationship.
***** There should be these four categories.
****** with no transitive relation (TR) to the others
 black, last
****** with some TR to the others, but not *this* TR
 that is, not related to anything else in the list by the TR that currently orders the list
****** related to others in the list by the TR ordering the list
****** related to others *not* in the list by the TR ordering the list
**** by default, sort by the first applicable sort criterion
 in each group of search results -- top-level or otherwise.
 Change ExprTree.insertSearchResults_atFocus
   based on RunParsed.runParsedCommand
**** indicate the sort applied to each view-fork
e.g. in parens, following the name of the fork
or with a typed-in command that shows it in the reassurance window.
**** DONE , right? keyboard command to change the sort on a group
***** later, a "sort program" buffer
Specific to a given VExpr, applied to its children.
Shows every TR, and a checkbox next to the one curently ordering the list.
The checkbox can be moved.
*** ? needs a closure algorithm
Suppose [a,b,c] are to be shown, and a > b, and c > d.
None of them are isolated from the closure of (>),
but among [a,b,c], c is isolated.
It should be shown in the unsorted group.
*** ? compromise: don't consider non-local connections
** TODO rewrite the PTree class
*** the new type
It can be like Data.Tree.Zipper, but using PointedLists (Plists).
The focus and its peers are represented as a PList of PTrees.
The ancestors are represented like in Data.Tree.Zipper:
each is a (reversed [PTree a]) a [PTree a].
Moving sideways is just a PList op.
Moving up or down requires converting one level between the PList and ancestor representations.
*** TODO first survey how I use it
It's only used in Hode.UI.
Potentially tricky:
  building a tree from the top while knowing where the focus is.
  Optics (refer to the PointedList implementation).
** TODO establish an informal schema
*** TODO Is (#maybe _) different from (#question _)?
(#question _) seems more general -- it permits non-boolean members.
*** AMR might be useful
 https://github.com/nschneid/amr-tutorial/raw/master/slides/AMR-TUTORIAL-FULL.pdf
 (in my Downloads/ folder)
** TODO optic ideas
*** Tree has an Ix class.
 I could write one for the Rslt, which might make following paths easier.
*** TODO are there other getters I should rewrite as folds?

** TODO is PTree focus buggy?
 When I run `st <- ui`, look through a small view-tree,
 and then exit and study `st`, I find many nodes for which `pTreeHasFocus`
 is `True`. This seems to contradict a comment in PTree.Initial, that
 "If it has focus, none of its children should."
** TODO unify cyclesInvolving, connections, and things yet to write
 something yet to write: like connections or cyclesInvolving, but it only returns the first thing it finds, rather than all of them.

 cyclesInvolving returns a set of cycles (whole paths), which is inefficient in its only current use context, the CycleBuffer. It should only return one.

 reachable gives everything reachable from a set of origins; the target set is unrestricted. It doesn't give the path, just the destination.
* TODO pressing
** TODO tests for the UI
*** St could be Eq and Ord
if I made (probably orphan) instances for Brick.Widgets.Edit.Editor
** TODO error window: Why is it treated differently?
** TODO reading and navigation are slow
*** would help: hide in context
in the context of golf, any phrase ending in "of golf"
can be omitted
**** how not to repeat a context?
 My data currently includes (fake addresses):
   @1: extend ##o columns #of hode
   @2: #to @1 #do ...

 As it stands that's fine,
 but I would like to create a Hode to-do list:
   @3: #for hode #do @1
 i.e.
   @3: #for hode #do (extend ##o columns #of hode)
*** would help: synonyms
*** would help: don't group single items
*** might help ? better columns
Some as counts, some otherwise.
*** might help ? distinguish "of interest" expressions
** TODO templates for sets of arbitrary size
** count more stuff in the left column(s)
*** ? use hMatches
*** let the user add HExprs to _columnHExprs
*** let each HExpr column be given a title
*** let each buffer keep its own list of HExprs
*** indicate matches ala chmod
A single decimal (hex) digit can indicate whether an `Expr`
matches up to 3 (4) separate `HExpr`s.
** TODO filters, throughout the view-Porest
not just its top level
* TODO easy
** TODO rename "command window" -> "minibuffer"
** TODO use HasCallStack to mark partial functions.
 https://www.tweag.io/posts/2020-04-16-exceptions-in-haskell.html
** TODO don't print zeroes in the columns
** TODO insertion list
*** plan
**** data St = ...
+  , _insertionBuffer :: Buffer
**** initially, just add the final result of insertions
**** then refactor insertion so it returns the full history of added things
*** complications
(1) inserting a compound expression inserts subexpressions
(2) don't record insertion if it already existedx
** TODO the color "white text on black background"
** TODO new in GHC 8.10: :instances
Given a type, shows its classes.
** TODO shortcut to empty the command window
was implemented already once
** TODO merge two nodes
*** why
e.g. because (and why can this happen?)
two identical templates exist at different addresses.

For an example of that error,
see jbb/ until (but not after)
commit 15201a6561b4181695f72bcb176136f43c94f853
*** how
If they are not identical, one of them is the "survivor".
They can be templates, if they have the same arity.
** TODO upon save, delete unused phrases and templates
unless maybe it's a long phrase
PITFALL: But don't delete the empty string.
         Or maybe the need for the empty string is obsolete?
