:PROPERTIES:
:ID:       0022503a-7ad9-4779-8006-661464de9f91
:END:
#+title: Gleam (programming language)
* why
  It's like Erlang with strong types.
* TODO what about concurrency?
** what the Gleam Book suggested
   "To find out more about Erlang fault tolerance see the Gleam OTP project and the Learn You Some Erlang chapter on supervisors."
   https://gleam.run/book/tour/assert.html
** where I could file an issue
   https://github.com/gleam-lang/suggestions/issues/
* the language
** Boolean logic
*** && and // are lazy
    unlike Erlang.
*** most operators are not builtin
    e.g. `not` is not builtin.
    Instead see the module
      gleam/bool
** numbers
*** the operators for floats and ints are different
    The float operators look the same followed by a period.
*** Numeric underscores are permitted.
*** blocks return the value of their last expression
    but every expression in the block is evaluated.

    let value: Bool = {
        "Hello"
        42 + 12
        False
    } // => False
*** use postfix `.n` to access the (n-1)th value in a tuple
*** pattern matching
**** names in pattern matches
     case xs {
       [[_, ..] as inner_list] -> inner_list
         # The _ ensures the list is nonempty.
       other -> []
     }
**** conditions in pattern matches: use `if`
     case xs {
       [a, b, c] if a == b && b != c -> "ok"
       _other -> "ko"
     }
**** `or` on pattern matches
     case number {
       2 | 4 | 6 | 8 -> "This is an even number"
       1 | 3 | 5 | 7 -> "This is an odd number"
       _ -> "I'm not sure"
     }
*** case switches can pattern match
    case x, y {
      1, 1 -> "both are 1"
      1, _ -> "x is 1"
      _, 1 -> "y is 1"
      _, _ -> "neither is 1"
    }
** functions
*** a template
    pub fn add(x: Int, y: Int) -> Int {
      x + y
    }
*** functions as arguments look funny
    pub fn twice ( f: fn(t) -> t,
                   x: t )
		   -> t {
      f ( f ( x ) )
    }
*** (|>) is like ($) in Haskell but backwards
**** the idea
     These are equivalent:

     iodata.to_string(iodata.reverse(iodata.new(string)))

     string
     |> iodata.new
     |> iodata.reverse
     |> iodata.to_string
**** for functions of multiple arguments
     see "Function capturing"
     https://gleam.run/book/tour/functions.html
** type variables are lowercase
** PITFALL: argument labels (optional) can differ from argument variable names
   pub fn replace(
     in string: String,
     each pattern: String,
     with replacement: String,
   ) {
     // The variables `string`, `pattern`, and `replacement` are in scope here
   }

   replace(in: "A,B,C", each: ",", with: " ")
** anonymous functions
*** a template
    fn(x, y) { x + y }
*** some nice shorthand
    if the anonymous function is of one argument,
    and just hands that argument to some multi-argument function,
    you can skip the `fn` formalism:

    pub fn run() {
      // This is the same as add(add(add(1, 3), 6), 9)
      1
      |> add(_, 3)
      |> add(_, 6)
      |> add(_, 9)
    }
*** PITFALL: some confusing shorthand
    This usage:

    pub fn run() {
      // This is the same as add(add(add(1, 3), 6), 9)
      1
      |> add(_, 3)
      |> add(_, 6)
      |> add(_, 9)
    }

    """
    is so common that there is a special shorthand for it.

    pub fn run() {
      // This is the same as the example above
      1
      |> add(3)
      |> add(6)
      |> add(9)
    }
    The pipe operator will first check to see if the left hand value
    could be used as the first argument to the call,
    e.g. a |> b(1, 2) would become b(a, 1, 2).

    If not it falls back to calling the result of the right hand side
    as a function , e.g. b(1, 2)(a).
    """
** modules and exports
*** Functions not marked "pub" are private to that module.
*** Complete qualification is not needed to call imported functions.
    // inside src/nasa/moon_base.gleam

    import nasa/rocket_ship

    pub fn explore_space() {
      rocket_ship.launch() // Note that `nasa` is omitted.
    }
*** Imported modules can be qualified.
    import unix/cat
    import animal/cat as kitty
*** (selective) unqualified imports
    import animal/cat.{Cat, stroke}

    pub fn main() {
      let kitty = Cat(name: "Nubi")
      stroke(kitty)
    }
*** The prelude, `gleam`, can be explicitly imported.
    Can be useful for avoiding name conflicts.
** user-defined types
*** template
    pub type Cat {
      Cat(name: String, cuteness: Int)
    }
*** Sum type definitions separate constructors with newlines.
    pub type Bool {
      True
      False
    }
*** In product types, fields can be accessed with (.).
    let cat = Cat(name: "Nubi", cuteness: 2001)
    cat.name // This returns "Nubi"
*** generic types
    pub type Box(inner_type) {
      Box(inner: inner_type)
    }
*** `opaque` lets a public type's fields and constructors be private.
    pub opaque type Counter {
      Counter(value: Int)
    }
*** record updates
    Use `..<name>` to fill in the unspecified records.
    PITFALL: Records is immutable; "updates" actually create new data.
**** example
     pub type Person {
       Person(
         name: String,
         age: Int,
         is_happy: Bool,
       )
     }

     pub fn have_birthday(person) {
       Person(..person, age: person.age + 1, is_happy: true)
     }
** Result (type)
   pub type Result(value, reason) {
     Ok(value)
     Error(reason)
   }
** `try` short-circuits Result computations.
   try int_a = parse_int(a)
   try int_b = parse_int(b)
   try int_c = parse_int(c)
   Ok(int_a + int_b + int_c)
** `assert` can bind variables and crash.
    assert Ok(i) = parse_int("123")
    // If it matched, now `i` is 123.
    // If it didn't, the assert has crashed.
** `todo` is like Haskell's "error"
*** The message is optional.
    fn favourite_number() -> Int {
      todo("We're going to decide which number is best tomorrow")
    }
*** Can be used for type inspection.
    fn main() {
      my_complicated_function(
        // What type does this function take again...?
        todo
      )
    }
** constants
   pub const numberOfDucks : Int = 100
** type alias
   pub type Headers =
     List(#(String, String))
** SKIPPED: bit strings
   https://gleam.run/book/tour/bit-strings.html
** SKIPPED: external (BEAM) functions
   https://gleam.run/book/tour/external-functions.html
** SKIPPED: external (BEAM) types
   https://gleam.run/book/tour/external-types.html
