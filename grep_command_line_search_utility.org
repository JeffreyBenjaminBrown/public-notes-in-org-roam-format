:PROPERTIES:
:ID:       ee83ddd1-aeaa-46e9-a6a7-d180ac16471f
:END:
#+title: grep (command line search utility)
* grep excluding nonreadable file types
  find . -type f -not \( -name "*.csv" -o -name "*.xlsx" -o -name "*.tgz" -o -name "*.zip" -o -name "*.ssv" -o -name "*.sav" -o -name "*.pyc" -o -name "*.pdf" -o -name "*.jpeg" -o -name "*.odt" -o -name "*.pack" -o -name "*.ods" -o -name "*.ipynb" -o -name "*.idx" -o -name "*.docx" -o -name "*.dta" \) -print0 | xargs -0 grep "xxx" --color
* grep for within-file (not within-lilne) conjunction
  all files containing both A and B, not necessarily on the same line
  Here A = "aws" and B = "iam"
  grep "aws" -r . -l | xargs grep "iam"
* grep for within-line disjunction
** tricks, necessary and maybe otherwise
*** necessary : grep -E
*** dubious : single-quotes around the regex
**** details
     so that the | is not interpreted as a pipe.
     Someone suggested that somewhere,
     but in my test it appears not to be true --
     I can put double-quotes aroudn it and it works perfectly.
**** a test for whether it is necessary
***** make a file containing this
      a
      b
***** grep for this
      grep -E "a|b" -r .
** example
   grep -r . -E 'saveStage|to_csv'
