:PROPERTIES:
:ID:       784007e7-b851-4988-beaa-b8e4a9657357
:END:
#+title: Haskell
* PITFALL: (Cabal?) REPL can't reload changes in depended-on projects.
  Evidence:

jeff@jbb-dell:cabal-experim$ tree
.
├── cabal.project
├── P1
│   ├── app
│   │   ├── Lib.hs
│   │   └── Main.hs
│   └── P1.cabal
└── P2
    ├── P2.cabal
    └── src
        └── MyLib.hs

jeff@jbb-dell:cabal-experim$ cabal repl P1 P2
cabal: Cannot open a repl for multiple components at once. The targets 'P1'
and 'P2' refer to different components.

The reason for this limitation is that current versions of ghci do not support
loading multiple components as source. Load just one component and when you
make changes to a dependent component then quit and reload.
* [[id:cbd1f56f-efef-4302-b309-e21ca0c1b677][how to profile in Haskell]]
* [[id:ffa6b210-d70c-4445-b0ed-87e3c6da00a7][To use a different version of GHC in Nix]]
* debugging in Haskell
** [[id:ca586cff-5010-4624-8886-9d53915e5469][Debug.Trace.trace (Haskell library) is magic]]
* testing in Haskell
** [[id:2cef696d-5d06-4b95-b22f-94bf819e4f68][QuickCheck and Microspec]]
* lenses in Haskell
** Generate lenses for third-party libraries in Haskell
   https://ai-jobs.net/?rdt_cid=3040091042633392170
* Haskell stuff I'd like to use
** [[id:42458f39-c09a-4af4-82da-1bd74967b046][Yi is a Haskell library for building text editors.]]
** PostgREST: Make a db API-modifiable
   https://postgrest.org/en/v8.0/index.html
** data-interval
   :PROPERTIES:
   :ID:       08945d69-be8f-4302-a633-e2569183f551
   :END:
   https://hackage.haskell.org/package/data-interval-2.1.1
** Hedgehog for websites
   https://quickstrom.io/
* laziness and strictness in Haskell
  [[id:a2c7b53c-4728-407a-8f2e-35d4e0a20138][Making Invalid Laziness Unrepresentable (article)]]
* Haskell language extensions
** Pattern synonyms
   {-# LANGUAGE PatternSynonyms #-}

   pattern F :: Int -> Int -> Foo
   pattern F f s = Foo f s

   Which abbreviates a frequently used constructor.
   Works in pattern matches too.
* effects systems in Haskell
** how semantics (e.g. order of evaluation) differ across libraries
   "The effect semantics zoo", Alexis King:
   https://github.com/lexi-lambda/eff/blob/8c4df4bf54faf22456354be18095b14825be5e85/notes/semantics-zoo.md
* solutions
** for space leaks
   [[id:a2c7b53c-4728-407a-8f2e-35d4e0a20138][Making Invalid Laziness Unrepresentable (article)]]
** converting to Floating types
   GHC.Real.realToFrac :: (Real a, Fractional b) => a -> b
   It's not part of any typeclass.
** dynamic programming in Haskell via lazy self-reference
   :PROPERTIES:
   :ID:       e933a77d-2304-4b84-93e3-27963bad5386
   :END:
   https://fpunfold.com/2022/01/09/haskell-dp.html
** the "cabal: Version mismatch between ghc and ghc-pkg" error
   It happened when I ran `cabal repl`.
   I solved it by deleting `dist-newstyle/` and rebuilding.
* some Haskell libraries
** [[id:ca586cff-5010-4624-8886-9d53915e5469][Debug.Trace (Haskell library) is magic]]
** [[id:3c92b639-c552-42d7-87e2-7fd1cf560f74][System.Random (Haskell library)]]
** [[id:2cef696d-5d06-4b95-b22f-94bf819e4f68][QuickCheck (Haskell library)]]
