:PROPERTIES:
:ID:       5c051765-a400-487f-9e31-4fe75a6eeaec
:END:
#+title: how Skg works
* TODO revise [[id:a7fe702f-518c-4886-8d97-1153e75092a0][viewing the data]]
  (I just <2025-11-05 Wed> revised the rest of this doc.)
* foundation : org-mode
** org-mode is both a format and a program.
   The org-mode program is called a 'minor mode' of Emacs,
   which has many others.
** the org-mode format
*** Each document has sections, subsections, sub-subsubsections, etc.
    Actually a document doesn't need more than one level.
    In that case it is a 'flat tree', a.k.a. a list.
*** Each section, subsection, etc. is a 'node' or 'org node'.
    :PROPERTIES:
    :ID:       94091f94-5bf7-4296-8509-f9cc3e88cc2e
    :END:
**** Each org node can be thought of as having four properties:
     level    : int -- represented by the number of leading asterisks
     title    : string
     body     : optional string
     children : list of other org-nodes, often empty
**** It is often handy to 'fold' a node.
     'fold' is Emacs-speak for 'hide the body and children of'.
*** 'containment'
**** 'Levels' (the asterisks) imply containment.
     For any headline H at level N,
     the most recent headline with level < N
     is said to 'contain' H.
     Equivalently, that headline is H's 'parent',
     and H is its 'child'.
**** Some nodes are not contained.
     These are 'roots' or 'top-level nodes'.
*** Folding (hiding contents) makes complex trees readable, navigable.
* terms from org-mode that I use
** fold
   = hide a node's children (and body), showing only the title
** parent and child
   In the display, the parent-child relationship
     can be used to display multiple kinds of relationship.
   In the Skg graph there are no parents or children --
     there are more explicit relationships.
** [[id:94091f94-5bf7-4296-8509-f9cc3e88cc2e][OrgNode]]
* client, server and graph
** the graph
   is the user's collection of knowledge.
   The user need not be the sole author --
   Skg lets you integrate other authors' notes into your own,
   and manipulate them as if you did own them.
   More on the graph [[id:95e56b22-e337-4f25-8a69-79289cfbbd6a][below]].
** the 'client'
   is an app that permits a user to view and manipulate the graph.
   So far the only client is written for Emacs,
   but there could be others.
** The 'server'
   is an app that the user only controls through the client.
   The server manipulates the graph,
   and creates views of it (as plain text) for the client.
* the graph
  :PROPERTIES:
  :ID:       95e56b22-e337-4f25-8a69-79289cfbbd6a
  :END:
** consists of 'nodes'
*** what that means
    Each node has a 'title' (some text that is always shown),
    a 'body' (some text that can be hidden),
    and some relationships to other nodes.
*** PITFALL: Nodes and OrgNodes are different.
    Nodes are the fundamental unit of knowledge in a Skg graph.
    OrgNodes are used to represent some portion of the Skg graph.
    Most OrgNodes correspond directly to a node in the graph,
    but there are important exceptions,
    used to encode other kinds of data.
** two familiar relations
*** Nodes contain each other.
**** language
     A 'container' node 'contains' a 'contained' node.
**** Most people write forests.
***** definitions
      A forest is just a collection of trees.
      A tree is just a document with sections,
        which contain subsections,
        which contain sub-subsections,
        etc.
***** Everything is contained in at most one container.
      The ones that aren't are (document) 'roots'.
**** Skg is more general -- data can overlap and cycle.
***** Overlap can be reasonable.
      For instance, if you have topics X and Y,
      then "X v. Y" could reasonably be contained in both.
***** Permitting cycles is not obviously important.
**** Each node implies a recursive 'containment view'.
***** 'contains'  is the default meaning
       of the child-parent relationship:
       Unless otherwise indicated,
       an org-parent 'contains' each of its org-children.
***** But other relationships can also be depicted
       via the parent-child medium.
       Special glyphs on a node indicate when
       its relationship to its parent is not the default.
*** Nodes link to each other.
**** language
     a 'source' node 'hyperlinks_to' a 'target' node.
**** link representation
     These are encoded 'inline' in the text,
     just as in org-roam.
     Except for the whitespace around the brackets and colon
     (of which there should be none) they are represented as:
       [ [ id : long-number ] [ any-title-however-misleading ] ]
**** link appearance
     A title or (as in this case) body
     can have [[_][any]] number of [[_][links]] with [[id:long-number][any title, however misleading]].
**** why use links
***** They let 'documents' stay reasonably-sized.
      where 'document' = recursive containtment view
***** They let a user put content a click or so farther away.
      This prevents the linked-to content
      from 'interrupting' a reader's view
      of whatever the writer thought was more important.
** three novel relations
*** Nodes can subscribe to each other.
**** language
     A 'subscriber' node 'subscribes' to a 'subscribee' node.
**** Subscriptions are for sharing.
     It is imagined that the subscribing and subscribed-to nodes
       should belong to different graphs by different authors.
**** A subscriber provides a view of its subscribees.
     That is not necessarily the node's only purpose:
     it can also have content unrelated to its subscriptions.
*** Node N can filter node F from N's subscriptions.
**** language and definition
     A 'hider' node 'hides_from_its_subscriptions' a 'hidden' node.
     If S subscribes to T, this relation allows S to hide
       any of T's contents from S's "subscription view" of T.
**** Filtering subscriptions facilitate integration.
     A subscription view will shrink as the subscribee's contents
     are integrated into the subscriber's graph.
     That is because once they are visible in the new place,
     they do not need to be shown in the subscription, too.
**** Even a completely-filtered subscription is valuable.
     If a subscribee's author adds new nodes to it,
     that new (to the subscriber) content
     will appear in the subscriber's view of the subscribee.
*** One node's view can override another's.
**** language and definition
     A 'replacement' node 'overrides_view_of' a 'replaced' node.
**** creating an overrider by editing someone else's node
     serial
***** User U is reading note N by user W.
***** U 'edits' N.
***** N is not changed (U does not own it).
***** Instead, N is overridden by a new node R
      which comes into being with
****** the title, body and content of N
****** a subscription to N
****** all of N's (current!) content hidden from its subscriptions
       That is, the content of N,
       which is identical to the content of R,
       is hidden from R's subscription-view of N.
       (Because why show those things in two places?)
***** U, who created R from N, can modify R however they like.
***** If W adds new content to N,
      the new content will be visible to U
      from R's subscription view of N.
** constraints
*** important : IDs should be unique.
*** not so important
    There are probably more constraints than these.
**** N should hide H from its subscriptions only if N subscribes to something that contains H.
***** the reasoning
      To record a 'hides' relationship
      with something that is not in a node's subscriptions
      would be wasteful but cause no problems.
***** implication : A node should not simultaneously subscribe to something and filter it from its subscriptions.
***** solution if violated
      If N subscribes to S and also hides S from its subscriptions,
      the first relation takes precedence, and the second is ignored:
      S will be shown among N's subscriptions.
**** A node should subscribe to anything it overrides.
***** the reasoning
      Presumably, if a user created node O,
      and O overrides foreign node F,
      it is because the user cares about F.
      Therefore they would probably like to be informed
      if the author of F adds content to it.
***** But the user can behave otherwise.
**** A node should not subscribe to its own recursive content.
     This would be redundant -- why show something in subscriptions,
     if it's already shown in content? -- but harmless.
* OrgNodes : how client and server communicate
** language
*** 'node' = an element of the graph
*** 'OrgNode' = an element of a view (in the client) of the graph
** Most orgnodes correspond to nodes in the graph.
   But there can be exceptions.
   For instance, an orgnode C might represent the collection of aliases
     for the node (in the graph) corresponding to C's parent P.
     If so, every child of C represents an alias of P.
** [[https://github.com/JeffreyBenjaminBrown/skg/blob/main/rust/types.rs][the orgnode type definitions]] (link to Github)
* .skg files : the ultimate source of truth
** Each corresponds to a node in the graph.
** The only data persistent across server sessions.
** Some TypeDB data must be calculated from these.
   Each time the server starts,
   the "in-relationships" (for all relations)
   and the out-links (for hyperlinks specifically)
   must be computed for each node.

   That's because .skg files record relationships
     in at most one direction:
     what the node contains, but not what contains it;
     what it subscribes to, but not what subscribes to it; etc.
   And one kind of relationship, hyperlinks,
     is not recorded explicitly in either direction;
     rather, link targets (sourced from this node)
       are parsed from any links in the text in the title and body,
     and link sources (that target this node)
       are similarly inferred from other files.
* viewing the data
  :PROPERTIES:
  :ID:       a7fe702f-518c-4886-8d97-1153e75092a0
  :END:
** By default, a node's contents are displayed as its children.
   That is, the relationship from parent to child,
   for *most* parent-child pairs,
   is that the parent contains the child.
** Each node therefore defines a recursive 'content view'.
*** A view is therefore usually of many nodes at once.
    That is, it corresponds to no single file on disk;
    rather, each headline corresponds to a separate .skg file.
** If a node appears more than once in a view, its contents are only shown the first time.
   This prevents infinite loops.
** One can request a 'containerward path view' at an orgnode.
   This inserts the node's container as its *child*
   (reversing the usual relationship),
   and then that thing's container as its child, etc.,
   recursing until it finds a cycle, a fork,
   or something with no container (a root).
   If it finds a cycle or a fork, that becomes the last thing
   displayed in the path.
** One can request a 'sourceward path view' at an orgnode.
   This is similar to the containerward path view:
   It inserts one new child into the node
   for each link source that targets the node.
   If there is only one such node,
   it recurses by inserting a sourceward view for that node,
   continuing until either it runs into:
     - a cycle
     - a 'fork': a node targeted by multiple nodes
     - a node targeted by nothing
   In the first two cases, the cycle or the fork is displayed
   as the last element of the path.
** One can request an 'aliases view' at an orgnode.
   Call that orgnode N.
   Doing this inserts into N a child entitled 'aliases',
   whose children (so N's grandchildren) are the aliases of N.
   This permits the user to edit the aliases of N.
** If a node N has subscriptions
   then the orgnode representing N
   has a child C entitled 'subscriptions',
   whose children (so N's grandchildren)
   represent each of the nodes N subscribes to (its subscribees).
   The contents of those subscribees (so N's great-grandchildren)
   are filtered to remove anything N hides from its subscriptions.
** If node N overrides node O
   then the orgnode representing N is shown instead of O
   wherever a view of O would otherwise have appeared --
   including inside a subscription view.
   (A glyph will indicate the override relationship to the user,
   who can choose to view the original if they wish.)
* yet to implement
** most of the sharing functionality
   That is, anything involving subscription, hiding or overriding.
** a diff view
