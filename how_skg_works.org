:PROPERTIES:
:ID:       5c051765-a400-487f-9e31-4fe75a6eeaec
:END:
#+title: how Skg works
* foundation : org-mode
** Each document has sections, subsections, sub-subsubsections, etc.
   Actually it doesn't need more than one level.
   In that case it is a 'flat tree', a.k.a. a list.
** Each section, subsection, etc. is a 'headline' in Emacs.
   Each headline has three properties:
     level : Int -- represented by the number of leading asterisks
     title : String
     body  : Optional String
   It is often handy to 'fold' (Emacs-speak for 'hide') the body.
** 'containment'
*** 'Levels' (the asterisks) imply containment.
    For any headline H at level N,
    the most recent headline with level < N
    is said to 'contain' H.
*** Some nodes are not contained.
    These are 'roots' or 'top-level nodes'.
** Folding (hiding contents) makes complex trees readable, navigable.
* terms from org-mode that I use
** fold
   = hide a node's children (and body), showing only the title
** parent and child
   In the display, the parent-child relationship
     can be used to display multiple kinds of relationship.
   In the Skg graph there are no parents or children --
     there are more explicit relationships.
* the graph
** consists of 'nodes'
   Each node has a 'title' (some text that is always shown),
   a 'body' (some text that can be hidden),
   and some relationships to other nodes.
** two familiar relations
*** Nodes contain each other.
**** language
     A 'container' node 'contains' a 'contained' node.
**** Most people write forests.
***** definitions
      A forest is just a collection of trees.
      A tree is just a document with sections,
        which contain subsections,
        which contain sub-subsections,
        etc.
***** Everything is contained in at most one container.
      The ones that aren't are (document) 'roots'.
**** Skg is more general -- the "forest" can overlap and cycle.
***** Overlap can be reasonable.
      For instance, if you have topics X and Y,
      then "X v. Y" could reasonably be contained in both.
***** Permitting cycles isn't obviously important.
**** Each node implies a recursive 'containment view'.
     'contains'  is the default meaning
       of the child-parent relationship:
       The org-parent 'contains' the org-child.
     Other relationships can also be drawn in the parent-child medium.
       Special glyphs on a node indicate when
       its relationship to its parent is not the default.
*** Nodes link to each other.
**** language
     a 'source' node 'hyperlinks_to' a 'target' node.
**** link representation
     These are encoded 'inline' in the text,
     just as in org-roam.
     Except for the whitespace around the brackets and colon
     (of which there should be none) they are represented as:
       [ [ id : long-number ] [ any-title-however-misleading ] ]
**** link appearance
     A title or (as in this case) body
     can have [[_][any]] number of [[_][links]] with [[id:long-number][any title, however misleading]].
**** why use links
***** They let documents to stay reasonably-sized.
***** They let you put content a click or so farther away.
** three novel relations
*** Nodes can subscribe to each other.
**** language
     A 'subscriber' node 'subscribes' to a 'subscribee' node.
**** Subscriptions are for sharing.
     It is imagined that the subscribing and subscribed-to nodes
       should belong to different graphs by different authors.
**** A subscriber provides a view of its subscribee.
     It can also have content unrelated to its subscriptions.
*** Node N can filter node F from N's subscriptions.
**** language and definition
     A 'hider' node 'hides_from_its_subscriptions' a 'hidden' node.
     If S subscribes to T, this relation allows S to hide
       any of T's contents from S's "subscription view" of T.
**** Filtering subscriptions facilitate integration.
     A subscription view should shrink as the subscribee's contents
       are integrated into the subscriber's graph.
     Now that they are visible in the new place,
       they do not need to be shown in the subscription, too.
**** Even a completely-filtered subscription is valuable.
     If the subscribee's author adds new nodes to the subscribee,
     those new (to you) nodes will appear
     in your subscriber's view of the subscribee.
*** One node's view can override another's.
**** language and definition
     A 'replacement' node 'overrides_view_of' a 'replaced' node.
**** creating an overrider by editing someone else's node
     serial
***** User U is reading note N by user W.
***** U 'edits' N.
***** N is not changed (U does not own it).
***** Instead, N is overridden by a new node R
      which comes into being with
****** the title, body and content of N
****** a subscription to N
****** all of N's (current!) content hidden from its subscriptions
       That is, the content of N,
       which is identical to the content of R,
       is hidden from R's subscription-view of N.
       (Because why show those things in two places?)
***** U, who created R from N, can modify R however they like.
***** If W adds new content to N,
      the new content will be visible to U
      from R's subscription view of N.
** constraints
*** important : IDs should be unique.
*** not so important
    There are probably more constraints than these.
**** N should hide H from its subscriptions only if it subscribes to something that contains H.
***** the reasoning
      To record a 'hides' relationship
      with something that is not in a node's subscriptions
      would be wasteful but cause no problems.
***** implication : A node should not simultaneously subscribe to something and filter it from its subscriptions.
***** solution if violated
      If N subscribes to S and also hides S from its subscriptions,
      the first relation takes precedence, and the second is ignored:
      S will be shown among N's subscriptions.
**** A node should subscribe to anything it overrides.
***** the reasoning
      Presumably, if user U
      created node O
      which overrides foreign node F,
      it is because U cares about F,
      and therefore would like to be informed
      if the author of F adds content to it.
***** But the user can behave otherwise.
**** A node should not subscribe to its own recursive content.
     This would be redundant -- why show something in subscriptions,
     if it's already shown in content? -- but harmless.
* orgnodes
** language
*** 'node' = an element of the graph
*** 'orgnode' = an element of a view of the graph
** Orgnodes are how the client and server communicate.
** Most orgnodes correspond to nodes in the graph.
   But there can be exceptions.
   For instance, an orgnode C might represent the collection of aliases
     for the node (in the graph) corresponding to C's parent P.
     If so, every child of C represents an alias of P.
** [[https://github.com/JeffreyBenjaminBrown/skg/blob/main/rust/types.rs][the orgnode type definitions]] (link to Github)
* .skg files : the ultimate source of truth
** Each corresponds to a node in the graph.
** The only data persistent across server sessions.
** Some TypeDB data must be calculated from these.
   Each time the server starts,
   the "in-relationships" (for all relations)
   and the out-links (for hyperlinks specifically)
   must be computed for each node.

   That's because .skg files record relationships
     in at most one direction:
     what the node contains, but not what contains it;
     what it subscribes to, but not what subscribes to it; etc.
   And one kind of relationship, hyperlinks,
     is not recorded explicitly in either direction;
     rather, link targets (sourced from this node)
       are parsed from any links in the text in the title and body,
     and link sources (that target this node)
       are similarly inferred from other files.
* viewing the data
** By default, a node's contents are displayed as its children.
   That is, the relationship from parent to child,
   for *most* parent-child pairs,
   is that the parent contains the child.
** Each node therefore defines a recursive 'content view'.
*** A view is therefore usually of many nodes at once.
    That is, it corresponds to no single file on disk;
    rather, each headline corresponds to a separate .skg file.
** If a node appears more than once in a view, its contents are only shown the first time.
   This prevents infinite loops.
** One can request a 'containerward path view' at an orgnode.
   This inserts the node's container as its *child*
   (reversing the usual relationship),
   and then that thing's container as its child, etc.,
   recursing until it finds a cycle, a fork,
   or something with no container (a root).
   If it finds a cycle or a fork, that becomes the last thing
   displayed in the path.
** One can request a 'sourceward path view' at an orgnode.
   This is similar to the containerward path view:
   It inserts one new child into the node
   for each link source that targets the node.
   If there is only one such node,
   it recurses by inserting a sourceward view for that node,
   continuing until either it runs into:
     - a cycle
     - a 'fork': a node targeted by multiple nodes
     - a node targeted by nothing
   In the first two cases, the cycle or the fork is displayed
   as the last element of the path.
** One can request an 'aliases view' at an orgnode.
   Call that orgnode N.
   Doing this inserts into N a child entitled 'aliases',
   whose children (so N's grandchildren) are the aliases of N.
   This permits the user to edit the aliases of N.
** If a node N has subscriptions
   then the orgnode representing N
   has a child C entitled 'subscriptions',
   whose children (so N's grandchildren)
   represent each of the nodes N subscribes to (its subscribees).
   The contents of those subscribees (so N's great-grandchildren)
   are filtered to remove anything N hides from its subscriptions.
** If node N overrides node O
   then the orgnode representing N is shown instead of O
   wherever a view of O would otherwise have appeared --
   including inside a subscription view.
   (A glyph will indicate the override relationship to the user,
   who can choose to view the original if they wish.)
* yet to implement
** most of the sharing functionality
   That is, anything involving subscription, hiding or overriding.
** a diff view
