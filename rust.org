:PROPERTIES:
:ID:       6c76685a-da5b-49e5-b3cd-fc7c552b6ca1
:ROAM_ALIASES: "cargo (Rust tool)" "rust (programming language)"
:END:
#+title: Rust (programming language)
* TODO READ | RESUME
** next section: https://doc.rust-lang.org/book/ch15-00-smart-pointers.html
** ch. 16, concurrency
   because my code uses it, at least when spawning threads
** RESUME in ch 17 at
   https://doc.rust-lang.org/book/ch17-02-concurrency-with-async.html
* TODO ? skipped
** [[id:489d77e6-1fca-4772-8d1b-71ec872aa0c1][lifetime elision rules]]
* tooling
** SOLVED [[id:b91d42ba-f87b-4bad-960b-2e1d467bee26][cargo and apt stopped working in Docker, could not connect]]
** how to initialize a project
*** shell.nix
**** PITFALL: Docker is easier
***** elaboration
      and some of my code is already
      made to work in this image:
      jeffreybbrown/hode:2025-03-13.rust-no-python
***** why
      Tantivy, for instance, I could not use in NixOS.
**** how
 { pkgs ? import <nixpkgs> {} }:

 pkgs.mkShell {
   buildInputs = with pkgs; [
     # Rust development
     rustc
     cargo
     rustfmt
     clippy

     # Required for Tantivy
     pkg-config
     openssl
     openssl.dev
   ];

   # Environment variables
   shellHook = ''
     export RUST_BACKTRACE=1
     export PKG_CONFIG_PATH="${pkgs.openssl.dev}/lib/pkgconfig:$PKG_CONFIG_PATH"
   '';
 }
*** cargo init --bin .
*** edit cargo.toml
 [dependencies]
 tantivy = "0.22"
*** cargo build
*** cargo run
** to build or run something other than main
   cargo {run, build} --bin executable-name
   where executable-name is defined in a bin passage,
   for instance
 #+BEGIN_SRC toml
 [[bin]] # more bin sections can be added
 name = "not-main"
 path = "not-main.rs"
 #+END_SRC
* language
** keywords
*** `impl` is for class methods and trait implementations.
**** using it for a class method
#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
#+end_src
**** using it for a trai implementations
#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
#+end_src
*** [[id:89ebb171-bc6c-4ff2-80ae-fa8215e32f18][`move` in closures]]
** Structs are product types.
** Enums are sum types.
*** define and use constructors
#+BEGIN_SRC rust
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
#+END_SRC
*** Fields can optionally be named.
**** PITFALL: Use braces, not parens, if naming fields.
**** example
#+BEGIN_SRC rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+end_src
*** can define a struct for each variant
#+BEGIN_SRC rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#+END_SRC
** `match` keyword
*** `match`
**** example
#+begin_src rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter {state : State},
}
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {state:?}!");
            25 } } }
#+end_src
**** The last, default, catch-all case is written `_`.
*** `if let` is shorthand for `match` with just one special case.
**** the idea
     These are equivalent.
***** via match
 let config_max = Some(3u8);
 match config_max {
     Some(max) => println!("The maximum is configured to be {max}"),
     _ => (), }
***** if let
 let config_max = Some(3u8);
 if let Some(max) = config_max {
     println!("The maximum is configured to be {max}");
 }
**** `if let else` permits a default case to be included.
     Without an else clause,
     the default result is to do nothing.
*** `let else` is shorthand for `match` that exits if no match
**** the idea
is that the match persists throughout the body of the function,
without needing extra wrapping braces.
In some cases this improves readability.
**** syntax
#+BEGIN_SRC rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
  let Coin::Quarter(state) = coin else {
    return None; };
  if state.existed_in(1900) {
    Some(format!("{state:?} is pretty old, for America!"))
  } else {
    Some(format!("{state:?} is relatively new."))
  } }
#+END_SRC
** errors
*** Result<T,E> is for recoverable errors.
**** [[id:8d275d24-2e2e-41bc-ba01-ed8ed5108f35][`main` can return () or Result.]]
**** There are functions for converting between Option and Result.
     :PROPERTIES:
     :ID:       63244e01-3a24-4f81-8cdb-4a97187b3146
     :END:
*** `panic!`, a macro, is for unrecoverable errors.
**** default behavior
     "By default, these panics will print a failure message, unwind, clean up the stack, and quit."
**** Optionally, can "unwind" down the call stack.
*** `Result` and `panic!` are often mixed.
#+BEGIN_SRC rust
use std::fs::File;

fn main() {
  let greeting_file_result = File::open("hello.txt");

  let greeting_file = match greeting_file_result {
    Ok(file) => file,
    Err(error) => panic!( // here
      "Problem opening the file: {error:?}"),
  };
}
#+end_src
*** Match on different kinds of errors using `error.kind()`.
**** using `match`
#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
  let greeting_file_result = File::open("hello.txt");

  let greeting_file = match greeting_file_result {
    Ok(file) => file,
    Err(error) => match error.kind() {
      ErrorKind::NotFound => match File::create("hello.txt") {
        Ok(fc) => fc,
        Err(e) => panic!("Problem creating the file: {e:?}"),
      },
      _ => {
        panic!("Problem opening the file: {error:?}");
      }
    },
  };
}
#+end_src
**** `unwrap` functions can be more concise
***** `unwrap` calls `panic!` on errors.
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
#+end_src
***** `expect` is like `unwrap` stated positively.
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
#+end_src
***** `unwrap_or_else` calls a lambda on errors.
#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}
#+end_src
*** The ? operator concisely propagates errors to callers.
**** REQUIREMENT: Errors must be convertible.
If ? is used to return an error,
that error must be convertible to the kind of error
in the function's return type of the function using the ?.
This is achieved by implementing `From<io::Error>`,
i.e. writing a passage that starts `impl From<io::Error>`.
**** It returns the errors and executes no more of the function.
**** syntax | example
#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
#+end_src
**** ? can be chained
#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();
    File::open("hello.txt")?.read_to_string(&mut username)?; // here
    Ok(username) }
#+end_src
*** ? also applies to Options.
    :PROPERTIES:
    :ID:       86b2d12c-8e17-4388-a543-3f5709f5e484
    :END:
** generics, traits, lifetimes
*** generics
**** Generics are free!
     They impose no performance penalty.
**** a generic function
     Use a type parameter (like T)
     and usually a trait (like PartialOrd).
 #+begin_src rust
 fn largest<T : std::cmp::PartialOrd>
   (list: &[T])
    -> &T
 { ... }
 #+end_src
**** a generic product type
 #+begin_src rust
 struct Point<T> {
     x: T,
     y: T,
 }
 fn main() {
     let integer = Point { x: 5, y: 10 };
     let float = Point { x: 1.0, y: 4.0 };
 }
 #+end_src
**** a generic method implementation
 #+begin_src rust
 struct Point<T> {
     x: T,
     y: T,
 }

 impl<T> Point<T> {
     fn x(&self) -> &T {
         &self.x
     }
 }

 fn main() {
     let p = Point { x: 5, y: 10 };

     println!("p.x = {}", p.x());
 }
 #+end_src
**** a method implementation for an instance of a generic type
 #+begin_src rust
 impl Point<f32> { // only for `Point` with type parameter `f32`
     fn distance_from_origin(&self) -> f32 {
         (self.x.powi(2) + self.y.powi(2)).sqrt()
     }
 }
 #+end_src
**** a method implementation can introduce type parameters beyond those of the type whose behavior it extends
     Below, the `mixup` function introduces X2 and Y2,
     only to extend the functionality of Point<X1, Y1>.
 #+begin_src rust
 struct Point<X1, Y1> {
     x: X1,
     y: Y1,
 }

 impl<X1, Y1> Point<X1, Y1> {
     fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
         Point {
             x: self.x,
             y: other.y,
         }
     }
 }

 fn main() {
     let p1 = Point { x: 5, y: 10.4 };
     let p2 = Point { x: "Hello", y: 'c' };

     let p3 = p1.mixup(p2);

     println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
 }
 #+end_src
*** traits and trait bounds
**** Traits group method signatures.
**** an example trait definition and implementation
     :PROPERTIES:
     :ID:       ea9c1172-b277-401a-b5a9-56eaba82c9f6
     :END:
#+begin_src rust
pub trait Summary {
  fn summarize(&self) // uses & because we should call summarize from a *reference to* the implementing type
               -> String;
  // there can be more method signatures here
}

pub struct NewsArticle {
  pub headline: String,
  pub location: String,
  pub author: String,
  pub content: String,
}

impl Summary for NewsArticle {
  fn summarize(&self) -> String {
    format!("{}, by {} ({})",
            self.headline, self.author, self.location) } }
#+end_src
**** Traits are not entirely open.
***** the restriction
      "... can’t implement external traits on external types. For example, we can’t implement the Display trait on Vec<T> within our aggregator crate because Display and Vec<T> are both defined in the standard library and aren’t local to our aggregator crate"
***** why
      "Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use."
**** default implementations
***** Traits can have default implementations.
#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    } }
#+end_src
***** "Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation."
***** "it isn’t possible to call the default implementation from an overriding implementation of that same method"
**** trait methods and ownership
     A trait method defined for `self` rather than `&self` will consume `self`.
***** example
#+begin_src rust
pub trait Into<T> {
    fn into(self) -> T;  // Takes ownership, consumes self
}
#+end_src
***** counterexample
#+begin_src rust
pub trait Summary {
  fn summarize
    (&self) // uses & because we should call summarize from a *reference to* the implementing type
     -> String;
}
#+end_src
**** `impl <trait>` v. `trait bound` syntax in signatures
     These are equivalent.
***** `impl <trait>` syntax
#+begin_src rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src
***** trait bound syntax
#+begin_src rust
pub fn notify
  <T: Summary> // NOTE: absent from the other one
  (item: &T) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src
**** Use + to specify multiple conditions on an argument.
pub fn notify(item: &(impl Summary + Display)) {
pub fn notify<T: Summary + Display>(item: &T) {
**** Use `where` to clean up signatures with complex trait bounds.
     equivalent alternatives
***** without `where`
#+begin_src rust
fn some_function
  <T: Display + Clone,
   U: Clone + Debug>
  (t: &T, u: &U) -> i32 {
#+end_src
***** with `where`
#+begin_src rust
fn some_function
  <T, U>
  (t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
#+end_src
*** a generic function with a trait bound
#+begin_src rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src
*** lifetimes
**** scope, lifetimes and dangling pointers : an error
     :PROPERTIES:
     :ID:       ed5db272-e8a4-4367-9510-f6cf1e2d6c49
     :END:
#+begin_src rust
fn main() {
    let r;
    {
        let x = 5;
        r = &x; // Since there's no `let` on this line,
                // this refers to the same `r` as earlier.
    } // x is now out of scope,
      // so r is a dangling pointer.
    println!("r: {r}");
}
#+end_src
**** the borrow checker
***** its logic
****** Loans are invalid if the borrower outlives the lender.
***** its goals
****** prevent dangling pointers
**** lifetime parameters | lifetime specifiers
***** some vocab
****** input lifetimes
       = lifetimes on function or method parameters
****** output lifetimes
       = lifetimes on return values
***** syntax
#+begin_src rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
#+end_src
***** example usage
****** code
#+begin_src rust
fn longest
  <'a>
  (x: &'a str, y: &'a str)
   -> &'a str
{ if x.len() > y.len() { x } else { y } }
#+end_src
****** practical interpretation
"the concrete lifetime that is substituted for 'a is the part of the scope of x that overlaps with the scope of y."
***** Type definitions can need lifetime specifiers.
      The type definition itself, not an instantiation of it.
****** the condition
       "you need to specify lifetime parameters for functions or structs that use references"
****** example
******* code
#+begin_src rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
#+end_src
******* interpretation
       This annotation means an instance of ImportantExcerpt can’t outlive the reference it holds in its part field.
***** Sometimes the compiler can infer lifetimes.
      It uses "lifetime elision rules" for this.
      These let the coder omit some lifetime annotations.
**** TODO ? I skipped some of this content.
     :PROPERTIES:
     :ID:       489d77e6-1fca-4772-8d1b-71ec872aa0c1
     :END:
     Mostly what was about lifetime rules.
     https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#thinking-in-terms-of-lifetimes
**** 'static => "lifetime could be the entire program duration"
***** All string literals are static.
***** Can be a bad temptation.
      "Most of the time, an error message suggesting the 'static lifetime results from attempting to create a dangling reference or a mismatch of the available lifetimes. In such cases, the solution is to fix those problems, not to specify the 'static lifetime."
*** syntax: using them all together
#+begin_src rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() { x } else { y }
}
#+end_src
** closures
*** basic syntax
#+begin_src rust
fn main() {
    let list = vec![1, 2, 3];
    let only_borrows = || println!("From closure: {list:?}");
    only_borrows();
}
#+end_src
*** `move` in closures
    :PROPERTIES:
    :ID:       89ebb171-bc6c-4ff2-80ae-fa8215e32f18
    :END:
    "to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn’t strictly need ownership, you can use the move keyword before the parameter list."
*** type signatures for closures
**** are optional unless the compiler gets confused
**** syntax example
#+begin_src rust
let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
#+end_src
*** Brackets might be optional.
    They are optional if the body only has one expression.
*** Closures capture values from their environment in three ways
    just like a function
**** borrowing immutably
**** borrowing mutably
**** taking ownership
*** (usually) invisible traits are applied to closures
**** FnOnce
     All closures implement this.
     "applies to closures that can be called once. All closures implement at least this trait because all closures can be called. A closure that moves captured values out of its body will only implement FnOnce and none of the other Fn traits, because it can only be called once."
**** FnMut
     "applies to closures that don’t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once."
**** Fn
     "applies to closures that don’t move captured values out of their body and that don’t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently."
** iterators
*** basic example
#+begin_src rust
let v1 = vec![1, 2, 3];
let v1_iter = v1.iter();
for val in v1_iter {
  println!("Got: {val}");
}
#+end_src
*** They all mutate, but it's not always marked.
    For instance, when an iterator is passed to a for loop,
    the for loop takes ownership, and makes its own mutable copy.
    Therefore the original iterator need not be marked `mut`.
*** iterating over immutable, owned and mutable values
**** `iter` returns immutable references.
**** `into_iter` returns owned values.
**** `iter_mut` returns mutable references.
*** consuming and iterator adapters
**** consuming adapter
     "Methods that call next are called consuming adapters because calling them uses up the iterator."
**** iterator adapters
     These produce different iterators,
     and don’t consume the iterator.
**** consuming a map uses both kinds
#+begin_src rust
let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> =
  v1.iter()
  .map(|x| x + 1) // produces a new iterator
  .collect(); // consumes the iterator, producing a collection
assert_eq!(v2, vec![2, 3, 4]);
#+end_src
** scope
*** [[id:ed5db272-e8a4-4367-9510-f6cf1e2d6c49][scope, lifetimes and dangling pointers]]
** Prefix an argument that is not modified with &.
   This means the function is passed a reference,
   which is efficient,
   and is not allowed to modify it,
   which is safe.
   Also, the caller can continue to use the argument,
   whereas without the & it would be unable to.
** unary prefix & creates a reference
   if    typedb_driver :  Arc<TypeDBDriver>
   then &typedb_driver : &Arc<TypeDBDriver>
** An Arc is not cloned from another Arc
   nor from what an Arc refers to,
   but from a reference to an Arc.
*** example
   let typedb_driver       : Arc<TypeDBDriver> =
     initialize_typedb();
   let typedb_driver_clone : Arc<TypeDBDriver> =
     Arc::clone( &typedb_driver );
** String literals are static.
** Static objects are copied rather than moved into "move closures".
** the stack and the heap
*** The stack is a LIFO store.
*** The heap is pointed-to memory.
    The memory allocator assigns to each pointer
    a certain region of the heap.
*** Pushing to the stack is faster than allocating (on the heap).
*** Accessing the stack is faster than accessing the heap.
*** Functions accordion the stack.
    Each function call pushes variables to the stack --
      local ones, and arguments.
    When it returns, what it pushed pops off.
** ownership
*** Ownership is for managing the heap.
*** Each value has exactly one owner at any time.
*** When an owner goes out of scope, its values are dropped.
*** Strings and ownership
**** A String is mutable. A string literal (&'static str) is not.
**** String::from creates Strings from string literals
     let strLiteral: &'static str = "string literal";
     let strFigurative: String = String::from(strLiteral);
**** 'drop' is called on it when a variable goes out of scope.
     The `drop` implementation depends on the type
     from which it is called.
*** Integers and Strings are copied differently.
**** syntax
     let x = 5;
     let y = x;
     let s1 = String::from("hello");
     let s2 = s1;
**** The copied String became invalid.
     After the line
       let s2 = s1;
     Rust considers s1 no longer valid.
**** Why the copied integer did not.
     "types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make."
*** Automatic copies are always shallow, cheap.
    "there's a design choice that’s implied by [the ownership model]: Rust will never automatically create “deep” copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance."
*** Cloning is deep.
*** the Copy trait
    "Rust has a special annotation called the Copy trait that we can place on types that are stored on the stack, as integers are ... If a type implements the Copy trait, variables that use it do not move, but rather are trivially copied, making them still valid after assignment to another variable."
*** Copy and Drop are mutually exclusive traits.
*** Nothing of variable size can implement Copy.
*** non-Copy variables can only be used once in a function!
    That's me talking; I might be wrong. But see this from the docs:
**** from the docs
 fn main() {
     let s =
       String::from("hello"); // s comes into scope

     takes_ownership(s);      // s's value moves into the function...
                              // ... and so is no longer valid here

     let x = 5;               // x comes into scope

     makes_copy(x);           // because i32 implements the Copy trait,
                              // x does NOT move into the function,
     println!("{}", x);       // so it's okay to use x afterward
 } // Here, x goes out of scope, then s.
   // Because s's value was moved, no heap memory is freed.

 fn takes_ownership(some_string: String) { // some_string comes into scope
     println!("{some_string}");
 } // Here, some_string goes out of scope and `drop` is called.
   // The backing heap memory is freed.

 fn makes_copy(some_integer: i32) { // some_integer comes into scope
     println!("{some_integer}");
 } // Here, some_integer goes out of scope.
   // No heap memory is freed.
*** When a function returns, its result is moved to its caller.
** concurrency
*** Threads are inside processes.
*** Done or not, a spawn ends when the `main` that spawned it does.
*** TRICKY: OS threads and Rust threads might correspond, or not.
    In the std lib, they correspond 1:1,
    but other crates can use other models.
*** Order of execution across threads is undefined.
*** Use JoinHandle.join() to ensure a thread finishes.
**** thread::spawn returns a JoinHandle<T>.
**** join() blocks the (caller?) until the joining thread completes.
**** example
 use std::thread;
 use std::time::Duration;

 fn main() {
     let handle = thread::spawn(|| {
         for i in 1..10 {
             println!("hi number {i} from the spawned thread!");
             thread::sleep(Duration::from_millis(1));
         }
     });

     for i in 1..5 {
         println!("hi number {i} from the main thread!");
         thread::sleep(Duration::from_millis(1));
     }

     handle.join().unwrap(); }
** (&), (*), references and borrowing
*** References are safer than pointers.
    "Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference."
*** borrowing = creating a reference
*** mutating borrowed things
**** cannot be done by default
**** to do it, create a "mutable reference"
**** syntax : use &mut rather than &
**** example
 fn main() {
     let mut s = String::from("hello");

     change(&mut s);
 }

 fn change(some_string: &mut String) {
     some_string.push_str(", world");
 }
*** While a mutable reference to x exists, no other reference* to x can exist.
    (*) regardless of mutability
**** why
     Users of an immutable reference don’t expect the value to suddenly change out from under them!
**** nuance: things go out of scope at their last use, even before that context ends
***** example: This is fine
      let mut s = String::from("hello");

      let r1 = &s; // no problem
      let r2 = &s; // no problem
      println!("{r1} and {r2}");
      // Variables r1 and r2 will not be used after this point.

      let r3 = &mut s; // no problem
      println!("{r3}");
*** Write &x to create a reference to x.
*** Write *r to dereference r.
*** References can be passed without changing ownership of the referent.
    fn main() {
        let s1 = String::from("hello");

        let len = calculate_length(&s1);

        println!("The length of '{s1}' is {len}.");
    }

    fn calculate_length(s: &String) -> usize {
        s.len()
    }
*** When a reference goes out of scope, its referent can persist.
*** A String is itself a pointer, so an &String is a reference to a pointer.
** async, await, Futures and Streams
*** Async is for [[id:c7224417-dcc0-40e1-ad5b-4d2cf94c4c1f][concurrency, not parallelism]].
*** Technically, all functions are blocking.
    "However, the term blocking is usually reserved for function calls that interact with files, the network, or other resources on the computer, because those are the cases where an individual program would benefit from the operation being non-blocking."
*** a "future" =
**** = a value of a type implementing the Future trait
**** = a value that may not be ready now but will become ready at some point in the future
*** "async" = "can be paused, resumed".
    can apply to blocks and functions
*** "await" = "here this async thing can be paused, resumed"
*** Appending `.await` transforms a Future<T> into a T.
*** "polling" = checking whether a future is available yet
*** some important crates
**** futures
     "The futures crate is an official home for Rust experimentation for async code, and it’s actually where the Future trait was originally designed."
**** tokio ("io")
     "Tokio is the most widely used async runtime in Rust today, especially for web application."
**** trpl ("the rust programming language")
     Educational.
     Re-exports some things from futures and tokio.
*** "futures are lazy"
    "they don’t do anything until you ask them to with the await keyword"
*** the "runtime"
**** Async code must be run from a "runtime".
     e.g. the function `trpl::run()`.
     `.await` cannot be used in `main` except within a runtime.
***** example
  #+BEGIN_SRC rust
  fn main() {
      let args: Vec<String> = std::env::args().collect();

      trpl::run(async {
          let url = &args[1];
          match page_title(url).await {
              Some(title) => println!("The title for {url} was {title}"),
              None => println!("{url} had no title"),
          } } ) }
  #+END_SRC
**** Each await hands control back to the runtime.
 "Each await point—that is, every place where the code uses the await keyword—represents a place where control is handed back to the runtime."
*** async hides an implicit Future
    "writing async fn is equivalent to writing a function that returns a future of the return type"
**** example: these are equivalent
***** with async
  #+BEGIN_SRC rust
  use trpl::Html;

  async fn page_title(url: &str) -> Option<String> {
    let response = trpl::get(url).await;
    // The Response object only has 3 things:: HTTP status code (200, etc.), Response headers, connection to stream. The data has not been streamed yet, which is why the next variable also uses `.await`.
    let response_text = response.text().await;
    Html::parse(&response_text)
      .select_first("title")
      .map(|title_element| title_element.inner_html()) }
  #+END_SRC
***** without it
  #+BEGIN_SRC rust
  use std::future::Future;
  use trpl::Html;

  fn page_title(url: &str) ->
  impl Future<Output = Option<String>> {
    async move {
      let text = trpl::get(url).await.text().await;
      Html::parse(&text)
        .select_first("title")
        .map(|title| title.inner_html()) } }
  #+END_SRC
*** Two futures can be raced.
**** example
***** providence
      this uses the `race` function from `trpl`, which is probably re-exported from something fundamental
***** Note that the futures are still wrapped.
      Neither `title_fut_1` nor `title_fut_2` in the code below
      is unwrapped using `await`. Both are instead
      passed as futures to `race`.
***** the code
  use trpl::{Either, Html};

  fn main() {
      let args: Vec<String> = std::env::args().collect();

      trpl::run(async {
          let title_fut_1 = page_title(&args[1]);
          let title_fut_2 = page_title(&args[2]);

          let (url, maybe_title) =
              match trpl::race(title_fut_1, title_fut_2).await {
                  Either::Left(left) => left,
                  Either::Right(right) => right,
              };

          println!("{url} returned first");
          match maybe_title {
              Some(title) => println!("Its page title is: '{title}'"),
              None => println!("Its title could not be parsed."),
          }
      })
  }

  async fn page_title(url: &str) -> (&str, Option<String>) {
      let text = trpl::get(url).await.text().await;
      let title = Html::parse(&text)
          .select_first("title")
          .map(|title| title.inner_html());
      (url, title)
  }
** some fast ways to do some things
*** read a file to a string
#+begin_src rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt") }
#+end_src
** orphans
*** Options
**** [[id:86b2d12c-8e17-4388-a543-3f5709f5e484][? also applies to Options.]]
**** [[id:63244e01-3a24-4f81-8cdb-4a97187b3146][There are functions for converting between Option and Result.]]
*** `main` can return {(), Result, more}.
    :PROPERTIES:
    :ID:       8d275d24-2e2e-41bc-ba01-ed8ed5108f35
    :END:
    "The main function may return any types that implement the std::process::Termination trait, which contains a function report that returns an ExitCode"
*** `return` is not needed for a function's last expression.
* using it with other systems
** [[id:88f580b2-b7a3-478d-9894-dbafebd2fc9e][TypeDB via Rust]]
* DONE solved
** [[id:b91d42ba-f87b-4bad-960b-2e1d467bee26][cargo and apt stopped working in Docker, could not connect]]
