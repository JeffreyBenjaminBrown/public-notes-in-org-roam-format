:PROPERTIES:
:ID:       6c76685a-da5b-49e5-b3cd-fc7c552b6ca1
:ROAM_ALIASES: "cargo (Rust tool)" "rust (programming language)"
:END:
#+title: Rust (programming language)
* TODO READ | RESUME
** ch. 16, concurrency
   because my code uses it, at least when spawning threads
** RESUME in ch 17 at
   https://doc.rust-lang.org/book/ch17-02-concurrency-with-async.html
* TODO questions
** What is `impl` for?
* tooling
** SOLVED [[id:b91d42ba-f87b-4bad-960b-2e1d467bee26][cargo and apt stopped working in Docker, could not connect]]
** how to initialize a project
*** shell.nix
**** PITFALL: Docker is easier
***** elaboration
      and some of my code is already
      made to work in this image:
      jeffreybbrown/hode:2025-03-13.rust-no-python
***** why
      Tantivy, for instance, I could not use in NixOS.
**** how
 { pkgs ? import <nixpkgs> {} }:

 pkgs.mkShell {
   buildInputs = with pkgs; [
     # Rust development
     rustc
     cargo
     rustfmt
     clippy

     # Required for Tantivy
     pkg-config
     openssl
     openssl.dev
   ];

   # Environment variables
   shellHook = ''
     export RUST_BACKTRACE=1
     export PKG_CONFIG_PATH="${pkgs.openssl.dev}/lib/pkgconfig:$PKG_CONFIG_PATH"
   '';
 }
*** cargo init --bin .
*** edit cargo.toml
 [dependencies]
 tantivy = "0.22"
*** cargo build
*** cargo run
** to build or run something other than main
   cargo {run, build} --bin executable-name
   where executable-name is defined in a bin passage,
   for instance
 #+BEGIN_SRC toml
 [[bin]] # more bin sections can be added
 name = "not-main"
 path = "not-main.rs"
 #+END_SRC
* language
** Structs are product types.
** Enums are sum types.
*** define and use constructors
#+BEGIN_SRC rust
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
#+END_SRC
*** Fields can optionally be named.
**** PITFALL: Use braces, not parens, if naming fields.
**** example
#+BEGIN_SRC rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+end_src
*** can define a struct for each variant
#+BEGIN_SRC rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#+END_SRC
** `match` keyword
*** `match`
**** example
#+begin_src rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter {state : State},
}
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {state:?}!");
            25 } } }
#+end_src
**** The last, default, catch-all case is written `_`.
*** `if let` is shorthand for `match` with just one special case.
**** the idea
     These are equivalent.
***** via match
 let config_max = Some(3u8);
 match config_max {
     Some(max) => println!("The maximum is configured to be {max}"),
     _ => (), }
***** if let
 let config_max = Some(3u8);
 if let Some(max) = config_max {
     println!("The maximum is configured to be {max}");
 }
**** `if let else` permits a default case to be included.
     Without an else clause,
     the default result is to do nothing.
*** `let else` is shorthand for `match` that exits if no match
**** the idea
is that the match persists throughout the body of the function,
without needing extra wrapping braces.
In some cases this improves readability.
**** syntax
#+BEGIN_SRC rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
  let Coin::Quarter(state) = coin else {
    return None; };
  if state.existed_in(1900) {
    Some(format!("{state:?} is pretty old, for America!"))
  } else {
    Some(format!("{state:?} is relatively new."))
  } }
#+END_SRC
** errors
*** Result<T,E> is for recoverable errors.
**** [[id:8d275d24-2e2e-41bc-ba01-ed8ed5108f35][`main` can return () or Result.]]
**** There are functions for converting between Option and Result.
     :PROPERTIES:
     :ID:       63244e01-3a24-4f81-8cdb-4a97187b3146
     :END:
*** `panic!`, a macro, is for unrecoverable errors.
**** default behavior
     "By default, these panics will print a failure message, unwind, clean up the stack, and quit."
**** Optionally, can "unwind" down the call stack.
*** `Result` and `panic!` are often mixed.
#+BEGIN_SRC rust
use std::fs::File;

fn main() {
  let greeting_file_result = File::open("hello.txt");

  let greeting_file = match greeting_file_result {
    Ok(file) => file,
    Err(error) => panic!( // here
      "Problem opening the file: {error:?}"),
  };
}
#+end_src
*** Match on different kinds of errors using `error.kind()`.
**** using `match`
#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
  let greeting_file_result = File::open("hello.txt");

  let greeting_file = match greeting_file_result {
    Ok(file) => file,
    Err(error) => match error.kind() {
      ErrorKind::NotFound => match File::create("hello.txt") {
        Ok(fc) => fc,
        Err(e) => panic!("Problem creating the file: {e:?}"),
      },
      _ => {
        panic!("Problem opening the file: {error:?}");
      }
    },
  };
}
#+end_src
**** `unwrap` functions can be more concise
***** `unwrap` calls `panic!` on errors.
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
#+end_src
***** `expect` is like `unwrap` stated positively.
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
#+end_src
***** `unwrap_or_else` calls a lambda on errors.
#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}
#+end_src
*** The ? operator concisely propagates errors to callers.
**** REQUIREMENT: Errors must be convertible.
If ? is used to return an error,
that error must be convertible to the kind of error
in the function's return type of the function using the ?.
This is achieved by implementing `From<io::Error>`,
i.e. writing a passage that starts `impl From<io::Error>`.
**** It returns the errors and executes no more of the function.
**** syntax | example
#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
#+end_src
**** ? can be chained
#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();
    File::open("hello.txt")?.read_to_string(&mut username)?; // here
    Ok(username) }
#+end_src
*** ? also applies to Options.
    :PROPERTIES:
    :ID:       86b2d12c-8e17-4388-a543-3f5709f5e484
    :END:
** generics, traits, lifetimes
*** to define a generic function
    Use a type parameter (like T)
    and usually a trait (like PartialOrd).
#+begin_src rust
fn largest<T : std::cmp::PartialOrd>
  (list: &[T])
   -> &T
{ ... }
#+end_src
** Prefix an argument that is not modified with &.
   This means the function is passed a reference,
   which is efficient,
   and is not allowed to modify it,
   which is safe.
   Also, the caller can continue to use the argument,
   whereas without the & it would be unable to.
** unary prefix & creates a reference
   if    typedb_driver :  Arc<TypeDBDriver>
   then &typedb_driver : &Arc<TypeDBDriver>
** An Arc is not cloned from another Arc
   nor from what an Arc refers to,
   but from a reference to an Arc.
*** example
   let typedb_driver       : Arc<TypeDBDriver> =
     initialize_typedb();
   let typedb_driver_clone : Arc<TypeDBDriver> =
     Arc::clone( &typedb_driver );
** String literals are static.
** Static objects are copied rather than moved into "move closures".
** the stack and the heap
*** The stack is a LIFO store.
*** The heap is pointed-to memory.
    The memory allocator assigns to each pointer
    a certain region of the heap.
*** Pushing to the stack is faster than allocating (on the heap).
*** Accessing the stack is faster than accessing the heap.
*** Functions accordion the stack.
    Each function call pushes variables to the stack --
      local ones, and arguments.
    When it returns, what it pushed pops off.
** ownership
*** Ownership is for managing the heap.
*** Each value has exactly one owner at any time.
*** When an owner goes out of scope, its values are dropped.
*** Strings and ownership
**** A String is mutable. A string literal (&'static str) is not.
**** String::from creates Strings from string literals
     let strLiteral: &'static str = "string literal";
     let strFigurative: String = String::from(strLiteral);
**** 'drop' is called on it when a variable goes out of scope.
     The `drop` implementation depends on the type
     from which it is called.
*** Integers and Strings are copied differently.
**** syntax
     let x = 5;
     let y = x;
     let s1 = String::from("hello");
     let s2 = s1;
**** The copied String became invalid.
     After the line
       let s2 = s1;
     Rust considers s1 no longer valid.
**** Why the copied integer did not.
     "types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make."
*** Automatic copies are always shallow, cheap.
    "there's a design choice that’s implied by [the ownership model]: Rust will never automatically create “deep” copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance."
*** Cloning is deep.
*** the Copy trait
    "Rust has a special annotation called the Copy trait that we can place on types that are stored on the stack, as integers are ... If a type implements the Copy trait, variables that use it do not move, but rather are trivially copied, making them still valid after assignment to another variable."
*** Copy and Drop are mutually exclusive traits.
*** Nothing of variable size can implement Copy.
*** non-Copy variables can only be used once in a function!
    That's me talking; I might be wrong. But see this from the docs:
**** from the docs
 fn main() {
     let s =
       String::from("hello"); // s comes into scope

     takes_ownership(s);      // s's value moves into the function...
                              // ... and so is no longer valid here

     let x = 5;               // x comes into scope

     makes_copy(x);           // because i32 implements the Copy trait,
                              // x does NOT move into the function,
     println!("{}", x);       // so it's okay to use x afterward
 } // Here, x goes out of scope, then s.
   // Because s's value was moved, no heap memory is freed.

 fn takes_ownership(some_string: String) { // some_string comes into scope
     println!("{some_string}");
 } // Here, some_string goes out of scope and `drop` is called.
   // The backing heap memory is freed.

 fn makes_copy(some_integer: i32) { // some_integer comes into scope
     println!("{some_integer}");
 } // Here, some_integer goes out of scope.
   // No heap memory is freed.
*** When a function returns, its result is moved to its caller.
** concurrency
*** Threads are inside processes.
*** Done or not, a spawn ends when the `main` that spawned it does.
*** TRICKY: OS threads and Rust threads might correspond, or not.
    In the std lib, they correspond 1:1,
    but other crates can use other models.
*** Order of execution across threads is undefined.
*** Use JoinHandle.join() to ensure a thread finishes.
**** thread::spawn returns a JoinHandle<T>.
**** join() blocks the (caller?) until the joining thread completes.
**** example
 use std::thread;
 use std::time::Duration;

 fn main() {
     let handle = thread::spawn(|| {
         for i in 1..10 {
             println!("hi number {i} from the spawned thread!");
             thread::sleep(Duration::from_millis(1));
         }
     });

     for i in 1..5 {
         println!("hi number {i} from the main thread!");
         thread::sleep(Duration::from_millis(1));
     }

     handle.join().unwrap(); }
** (&), (*), references and borrowing
*** References are safer than pointers.
    "Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference."
*** borrowing = creating a reference
*** mutating borrowed things
**** cannot be done by default
**** to do it, create a "mutable reference"
**** syntax : use &mut rather than &
**** example
 fn main() {
     let mut s = String::from("hello");

     change(&mut s);
 }

 fn change(some_string: &mut String) {
     some_string.push_str(", world");
 }
*** While a mutable reference to x exists, no other reference* to x can exist.
    (*) regardless of mutability
**** why
     Users of an immutable reference don’t expect the value to suddenly change out from under them!
**** nuance: things go out of scope at their last use, even before that context ends
***** example: This is fine
      let mut s = String::from("hello");

      let r1 = &s; // no problem
      let r2 = &s; // no problem
      println!("{r1} and {r2}");
      // Variables r1 and r2 will not be used after this point.

      let r3 = &mut s; // no problem
      println!("{r3}");
*** Write &x to create a reference to x.
*** Write *r to dereference r.
*** References can be passed without changing ownership of the referent.
    fn main() {
        let s1 = String::from("hello");

        let len = calculate_length(&s1);

        println!("The length of '{s1}' is {len}.");
    }

    fn calculate_length(s: &String) -> usize {
        s.len()
    }
*** When a reference goes out of scope, its referent can persist.
*** A String is itself a pointer, so an &String is a reference to a pointer.
** async, await, Futures and Streams
*** Async is for [[id:c7224417-dcc0-40e1-ad5b-4d2cf94c4c1f][concurrency, not parallelism]].
*** Technically, all functions are blocking.
    "However, the term blocking is usually reserved for function calls that interact with files, the network, or other resources on the computer, because those are the cases where an individual program would benefit from the operation being non-blocking."
*** a "future" =
**** = a value of a type implementing the Future trait
**** = a value that may not be ready now but will become ready at some point in the future
*** "async" = "can be paused, resumed".
    can apply to blocks and functions
*** "await" = "here this async thing can be paused, resumed"
*** Appending `.await` transforms a Future<T> into a T.
*** "polling" = checking whether a future is available yet
*** some important crates
**** futures
     "The futures crate is an official home for Rust experimentation for async code, and it’s actually where the Future trait was originally designed."
**** tokio ("io")
     "Tokio is the most widely used async runtime in Rust today, especially for web application."
**** trpl ("the rust programming language")
     Educational.
     Re-exports some things from futures and tokio.
*** "futures are lazy"
    "they don’t do anything until you ask them to with the await keyword"
*** the "runtime"
**** Async code must be run from a "runtime".
     e.g. the function `trpl::run()`.
     `.await` cannot be used in `main` except within a runtime.
***** example
  #+BEGIN_SRC rust
  fn main() {
      let args: Vec<String> = std::env::args().collect();

      trpl::run(async {
          let url = &args[1];
          match page_title(url).await {
              Some(title) => println!("The title for {url} was {title}"),
              None => println!("{url} had no title"),
          } } ) }
  #+END_SRC
**** Each await hands control back to the runtime.
 "Each await point—that is, every place where the code uses the await keyword—represents a place where control is handed back to the runtime."
*** async hides an implicit Future
    "writing async fn is equivalent to writing a function that returns a future of the return type"
**** example: these are equivalent
***** with async
  #+BEGIN_SRC rust
  use trpl::Html;

  async fn page_title(url: &str) -> Option<String> {
    let response = trpl::get(url).await;
    // The Response object only has 3 things:: HTTP status code (200, etc.), Response headers, connection to stream. The data has not been streamed yet, which is why the next variable also uses `.await`.
    let response_text = response.text().await;
    Html::parse(&response_text)
      .select_first("title")
      .map(|title_element| title_element.inner_html()) }
  #+END_SRC
***** without it
  #+BEGIN_SRC rust
  use std::future::Future;
  use trpl::Html;

  fn page_title(url: &str) ->
  impl Future<Output = Option<String>> {
    async move {
      let text = trpl::get(url).await.text().await;
      Html::parse(&text)
        .select_first("title")
        .map(|title| title.inner_html()) } }
  #+END_SRC
*** Two futures can be raced.
**** example
***** providence
      this uses the `race` function from `trpl`, which is probably re-exported from something fundamental
***** Note that the futures are still wrapped.
      Neither `title_fut_1` nor `title_fut_2` in the code below
      is unwrapped using `await`. Both are instead
      passed as futures to `race`.
***** the code
  use trpl::{Either, Html};

  fn main() {
      let args: Vec<String> = std::env::args().collect();

      trpl::run(async {
          let title_fut_1 = page_title(&args[1]);
          let title_fut_2 = page_title(&args[2]);

          let (url, maybe_title) =
              match trpl::race(title_fut_1, title_fut_2).await {
                  Either::Left(left) => left,
                  Either::Right(right) => right,
              };

          println!("{url} returned first");
          match maybe_title {
              Some(title) => println!("Its page title is: '{title}'"),
              None => println!("Its title could not be parsed."),
          }
      })
  }

  async fn page_title(url: &str) -> (&str, Option<String>) {
      let text = trpl::get(url).await.text().await;
      let title = Html::parse(&text)
          .select_first("title")
          .map(|title| title.inner_html());
      (url, title)
  }
** some fast ways to do some things
*** read a file to a string
#+begin_src rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt") }
#+end_src
** orphans
*** Options
**** [[id:86b2d12c-8e17-4388-a543-3f5709f5e484][? also applies to Options.]]
**** [[id:63244e01-3a24-4f81-8cdb-4a97187b3146][There are functions for converting between Option and Result.]]
*** `main` can return {(), Result, more}.
    :PROPERTIES:
    :ID:       8d275d24-2e2e-41bc-ba01-ed8ed5108f35
    :END:
    "The main function may return any types that implement the std::process::Termination trait, which contains a function report that returns an ExitCode"
*** `return` is not needed for a function's last expression.
* using it with other systems
** [[id:88f580b2-b7a3-478d-9894-dbafebd2fc9e][TypeDB via Rust]]
* DONE solved
** [[id:b91d42ba-f87b-4bad-960b-2e1d467bee26][cargo and apt stopped working in Docker, could not connect]]
