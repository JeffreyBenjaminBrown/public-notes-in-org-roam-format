:PROPERTIES:
:ID:       9c5619e5-81ad-4a67-9705-e4761bdd6839
:ROAM_ALIASES: "skg"
:END:
#+title: shareable knowledge gardens (skg)
* = an app being built here
  https://github.com/JeffreyBenjaminBrown/skg
** The README there might be the best introduction to skg.
* Claim: Shared note-taking is not yet feasible.
* TODO Rush to where I can use it for my own data.
** that seems better than this
*** What would it take to make this interesting enough for others to want to code it with me?
* [[id:1f76cbed-d2c5-4522-89e2-1de946d5dc99][knowledge graphs, some connectivity demos for]]
* promoting (duplicates)
** [[id:170e4f79-4f5e-49a6-9ce1-8e42c0332100][the meaning of sharing in a knowledge graph]]
* problems
** must understand what edits will be allowed from Emacs before I can specify what Rust sends
** private lenses onto your public notes
   would be just like subscriptions.
   Could even be a private lens onto a public subscription.
** [[id:170e4f79-4f5e-49a6-9ce1-8e42c0332100][the meaning of sharing in a knowledge graph]]
** [[id:83f4b23d-1f74-4dbb-9e22-2b121043362a][the two-nodes-with-the-same-ID problem]]
** [[id:7350d543-80b9-4bdb-8ca6-7e1ebc689373][What about skipped org-bullet levels?]]
** Anticipate a recursive containment relationship?
   = What to do if one tries to view an infinite (therefore non-tree, with a containment cycle) file?
** [[id:5eba18fb-8524-4073-b23c-b6fe5aa153f1][interactions between links, subscriptions and comments]]
* tasks left
* to replace org-roam (in my usage)
** Emacs build an s-exp for Rust.
** Rust acts on the s-exp from Emacs.
*** [[id:e707ded7-ff36-41cf-8ae1-672ab78e30d4][saving should bring a new document from Rust]], invisibly
*** Orphaned content becomes uncontained, not deleted.
** [[id:ab19097e-522f-4a88-ab9c-32b58fe38212][search for a title from Emacs]]
** indicators
*** show number (and kind?) of upstream nodes
    links
    subscriptions, unsubscriptions
*** show an "I" for "intermediating"
    Describes the relationship between N's parent
    and N's children, when it is not the standard one.
** visibly different bullets have addresses
** [[id:48940ef8-f7fb-47bd-ab96-20f30eb2831b][skg's own copy/paste mechanisms]]
** BLK_DATE complain about multiple containment on save
*** the idea
    If any of the nodes received (even the root!)
    is already contained in something in the graph,
    complain.
*** first [[id:48940ef8-f7fb-47bd-ab96-20f30eb2831b][make it difficult, maybe impossible]]
** a backward view
*** should be through at least three relations
    contains, subscribes, links to
** import/export*
*** export to org-roam
    would make people more willing to try skg
** persist TypeDB data
   consider too how Tantivy data is persisted
* for sharing & privacy
** a user config file
*** include for each repo
    Path to repo.
    Author-repo shorthand.
    Owned by user (bool).
    Color.
    Privacy level (for filtering, later).
** fetching the document (with sharing)
   Rust's s-exp for Emacs acts on all relations.
** saving (with sharing)
   Emacs's s-exp for Rust elicits appropriate changes regarding foreign nodes.
** operations on nodes
*** [[id:9301546a-f6d7-42ce-9034-8e3e0bc5536e][merging two nodes]]
*** "ignore" a node
    If node N subscribes to node S,
    any content-descendent of S can be ignored from N,
    not just S's immediate (first generation of) content.
    Or maybe just ignore globally.
*** "incorporate" a node
    This causes it to be ignored
    from its initial subscriber,
    but subscribed to somewhere else.
*** subscribe to a node
** metadata, flatter buffer
*** elaboration
    The title and, under it, metadata (author, ...)
    should be a special first-level node,
    first among its siblings.
*** [[id:1f87487f-af4a-4a32-84eb-da742b0a3f2e][an org-branch can be read-only and foldable]]
* diffs
** make aware of git diff
*** track the last-read commit
    When you read someone's note, you can tell your subscription "I am up to date on this", and it stores the commit that applied when you said that. The next time you look at it, if it has been updated, it uses the diff between the earlier version and the latest to show what's changed.
*** be able to construct a whole document from either commit
** views to navigate a diff of someone's graph
   at two different commits
*** from the high level: a list of all involved nodes,
    probably with statistics for each:
    new, deleted, moved
    change in in-link, out-link counts
    change in content volume
*** from the perspeective of a node that in both commits
 it is every node that changed
 {new, moved there, moved away, deleted}.
 Deleted things can be seen the way they were.
 Moved things can be seen in both ways.
 New things just have an indicator that they are new.
*** from the perspective of a new node
    it should show which of its contents are new,
    and which were brought in.
*** from the perspective of a deleted node
    we should see its former contents,
    and have access to what became of them
* non-obvious implied features
** Sharing and version control are independent.
   :PROPERTIES:
   :ID:       8faa302a-2a07-4cc9-8741-86a4e6b69f78
   :END:
   No need to look at diffs to think about sharing.
** Child content stored separately from child position.
** Subscriptions can be public and private.
** Unsubscriptions could I think be public and private.
   The trick: In a public context the privately unsubscribed-from nodes should not show up.
** Public subscriptions to private nodes reveal almost nothing.
   They reveal the fact of their existence,
   but not what they unsubscribe to -- not even its repo.
* cleaning
** automate the test of recursive_s_expression_from_node
*** in tests/content_view.rs
*** currently it prints to screen
* do later
** ? comment files
*** why not
    Subscription lenses seem to make it unnecessary.
*** how
**** when fetching a document, check whether each node has a comment
     and if so, display that as a first subnode,
     called "comments by: [author]"
**** Enable editing, somewhat.
     The title, "comments by: [author]" cannot be changed.
     But the comments themselves can be.
** graph constraints
*** test each constraint of the schema
    Some violations might not be representable in the .skg format.
*** Can a file include multiple comments_on properties?
    It shouldn't.
*** `contains` should be acyclic
    The TypeDB AI says I can use `distinct` instead,
    but the docs on `distinct` don't suggest that's true.
*** Ttest that all IDs are distinct in the repo.
    maybe in Rust, not TypeDB
** unify Tantivy and TypeDB indexation
*** If `titles` were the first field in the .skg format
    then the Tantivy indexing would need to read less
** [[id:2608f577-ab0a-4df7-9eba-b6f3042abbde][Is this how to write cardinality constraints on roles?]]
** later: track edit times for nodes on screen
   :PROPERTIES:
   :ID:       14321c6f-679e-406e-8076-cc58a8eaf9f1
   :END:
   Don't save a file if all of its (first-generation) content is older on screen than on disk.
   When first put on screen, each headline should be given the age of the source file.
** Don't search a repo's .git folder.
** ? Integrate :: Tantivy index , ?complete SKG format.
** Not every headline should be searchable.
   By default they should be,
   but the user should be able to turn that off.
** [[id:99ae154c-5dfc-4a95-9bdf-af09159c6da4][merges have subscription consequences]]
** nested links -- links in titles
*** the idea
    This is like creating a single-use relation type.
    Just like relatinoships with permanent types,
    this is useful because it automatically creates links
    to the items referenced in the title,
    rather than requiring the user to do that.
*** a representation: wrap all links in brackets
    :PROPERTIES:
    :ID:       91606c6f-0b09-4cb1-b4fe-81ca72a3f6ce
    :END:
**** example
***** for          titles with links
      [humility] engenders [peace]
***** for links to titles with links
      [[humility] engenders [peace]]
**** problem: It might be confusing that brackets are also used to indicate member types in [[id:cfa775eb-9107-430a-a32c-228901d0f494][relation type definitions]].
*** search over titles that include links
    Order results by title length,
    and if the title includes links,
    show them, rather than showing the whole title as one link.
** smart diff traversal
   treating nodes as first class entities,
   able to jump easily from any [change involving a node] to any of its brethren in an equivalence class, where equivalence is modulo insertion or deletion, modulo link text and any other links present in the same node, and modulo appearance as base content, subscription or unsubscription.
** smart diff view
   Transclude to see all insertions and deletions in a context.
** [[id:81d2fea0-f1b1-48a8-9934-5f09f5a5a3a0][extend the file format]]
** report references to a user's data
   The app should make it easy to see where
   a foreign repo refers to yours.
** Permit people to share their subscriptions with each other.
** A public notes repo should be configurable to contain only one commit.
   If so, it is the latest of a corresponding private repo.
** later ? [[id:41844d8a-f352-4e2d-8ba3-3c83b2dd2ac3][osc-gen style backlinks view]]
** "flat org diff" : for private lenses onto public [[id:08d6887d-8a86-4906-8ab3-6d93217de0fd][flat-org]] files
   :PROPERTIES:
   :ID:       38d2c92e-3ba0-46ca-bf32-756d59bea448
   :END:
   Each FOD file corresponds to an FO file.
   Each line of an FOD can have an "elder brother" ID, its own ID, and hypertext content.
   If the first line of an FOD has no elder brother ID, it is listed before all the FO's content in the merged FOD-FO view.
   If any other line of an FOD has no elder brother ID, it is listed right after the preceding element of the FOD in the merged view.
   Any FOD line with an FO elder brother is listed right after the elder brother in the merged view.
** show foreign moves of incorporated=merged=subscribed-to nodes
   If they moved something but you merged it with something of your own, maybe don't show the move, because you already placed it and you're already tracking it.
** relationships and types thereof
*** relationship type
**** fields
***** address
***** definition
      :PROPERTIES:
      :ID:       cfa775eb-9107-430a-a32c-228901d0f494
      :END:
      "[agent] knows [agent]", "_ needs _", etc.
****** Can be typed or not.
****** This should probably define the default name
       but the relation can have aliases.
***** other data, like an orgish file
**** problem: It might be confusing that brackets are also [[id:91606c6f-0b09-4cb1-b4fe-81ca72a3f6ce][used to indicate links]].
*** relationship
**** fields
     address
     relations type address
     members
**** problem: permits invalid type
     The relation type must correspond to the number of members.
**** justification
     If you create a relationship involving x and y,
     it automatically becomes visible from x and y,
     rather than requiring the user to visit them and link to it.
     (The user could still explicitly place it in either view,
     and maybe give different or additional link text.)
* fun to explain
** Each note is a collection of notes.
** Containment and linking are different.
   A context is a note contained in no other note.
   But a context, like any other note, can be linked to.
** public privacy and private privacy
   The user can insert a link to a private file anywhere, and the link might be public or not. When not, it is instead part of a corresponding file in their private repository, which refers to the public repository context that it modifies.
* architectural principles
** Avoid complex data structures in Emacs.
   Emacs seems best for buffer text.
   That text's properties can encode anything I need.
   All other logic, including types, should be in Rust.
* earlier work
** subscription model, I think needlessly complex
   You can subscribe any node in your graph to any node(s) in another's. Upon doing so you can then decide how to merge them, associating context-descendents in your context with ones in context(s) of theirs, and unsubscribing to branches not of interest (in your context).
   Unsubscriptions can be invisible or visible: "remove all content descending from here, and make here invisible" or just the first of those two things. It should be visibly obvious that visible unsubscribed nodes are unsubscribed.
   The user can attach their own context to a subscription. (This generalizes how a link can appear with non-link text in the same expression.) They could attach it in-line as text visibly not imported from the subscription, or (obviously) as descendent graph content if there's enough to warrant (in the user's eyes) structuring.
** spec
*** representation
**** IDs must proliferate, relative to org-roam.
     I don't see how to proliferate IDs if diffs are to be readable.
     Every element of a list involved in any other relationship
     (which includes having plain non-link text view-children)
     must have an ID, so that it can be moved.
**** Anything with a title can have an optional alias field.
*** views
**** kinds of data visible from a topic
***** The available curated views of it.
      These ought to be mergeable.
      For instance,
      if the private file on a has child b with grandchild c,
      and the public file on a has child b with grandchild c',
      the merge would contain a single child b with grandchildren c and c'.
***** The relationships it is in.
****** Speecial kind: Links to it.
***** Parts of the git diff involving it.
**** That relationships exist involving N not recorded in N can be seen from N.
***** wordier definition
      If node N is in relationship R,
      R might be part of N's contents (recursively), or not.
      If not, the fact that things like R exist
      should be visible from a view of N.
***** Indeed N need contain no curated content at all.
      In this case the only information visible from it
      are the relationships involving it.
**** The view of a recursive note must transclude.
**** Lists and sets can be shown on one line or across multiple.
*** [[id:60ac4c5c-fca6-4943-86ee-8f8f9011eaa6][skg : cloning seems unnecessary]]
