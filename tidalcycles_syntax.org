:PROPERTIES:
:ID:       543397e7-733f-4d56-bf58-35f5e9d83b5e
:END:
#+title: TidalCycles language: syntax, functions, signal flow
* see also
  [[id:8dfe7370-d359-4d4b-99f0-09cd9b0a9822][solutions \ Tidalcycles]]
* DONE reading
  https://tidalcycles.org/docs/patternlib/tutorials/workshop/
* TODO [[id:df2e01d2-1362-48fa-9f09-8d7d70cf31ec][questions about the TidalCycles language]]
* [[id:82eb4202-2da9-43b1-9f89-ab2d3d8fbbd1][effects in TidalCycles]]
* [[id:ae8d6109-5878-4c2e-b2b7-a6aacb980687][transformations (Pattern -> Pattern) in TidalCycles]]
* [[id:ec43fb48-eb6f-4942-bd3e-2aa7a8aa820c][synths in TidalCycles]]
* [[id:9898e99f-2a15-4085-97de-302f895572c4][u, new interactive Tidal notes <2023-10-31 Tue>]]
* voices in TidalCycles
** mute, solo, umute, unsolo
   `mute 1` mutes `d1` (which is a synonym for `p 1`).
   `solo` is similar.
** [[id:69be0c4b-551a-4c77-9185-84e784c2e4ef][truncating long samples : `cut` and `legato`]]
* elementary patterns
** `silence` (the symbol) is a pattern.
** `run n` gives n events, from 0 to n-1
   d1 $ s "[[bd sn]/2, arpy*2%3]*8" |*| speed (run 8 + 1/2)
* TODO polymeters in Tidal
  https://club.tidalcycles.org/t/thinking-time-in-addition-vs-division-meshuggah-style-prog-metal-in-tidal/4664/6
* [[id:e89c67a2-6f94-4466-8451-e7b03066aad1][continus parameter variation in Tidalcycles]]
* voices and signal flow in Tidal
** voice names
*** There are some "preassigned voices".
    `d1`, for instance.
    See BootTidal.hs for their definitions.
**** PITFALL: [[id:2b81a68f-cfa5-45fc-b61e-3db738463018][Preassigned voices also have voice names.]]
*** Voice names can be dynamic and informative.
    Rather than use the preassigned voice names like `d1`,
    one can name patterns as in
      p 1
    or
      p "juliet"
** TODO There are effects buses.
   :PROPERTIES:
   :ID:       d41a981f-1a73-44bf-85fb-f5a80d72bea3
   :END:
   https://club.tidalcycles.org/t/creating-effects-chains-or-audio-buses/3707
   https://github.com/tidalcycles/tidal-doc/issues/66
* TidalCycles "mini-notation"
** DONE internalized
*** ~ is silence
*** grouping
**** Each [] lasts as long as a single "event" in a pattern.
     So in "x [y z]" the x lasts as long as the [y z].
**** (.) can separate events like [] does.
     These are equivalent:
     "x . y z  . a b c"
     "x  [y z]  [a b c]"
**** (,) joins events simultaneously
     Does not work outside of brackets.
*** * = dense, / = sparse
*** x%y : rational number
*** (sample:number) selects the `number`th value of that sample
** Things in a <> group are cycled through.
   This plays "bd" every time, "sd" one third of the times, etc:
     d1 $ s "bd <sd hh cp>"
** randomness
*** (|) randmonly chooses between things
    "[a | b] c" always plays c, sometimes plays a.
*** postfix "?" sometimes replaces its argument with silence
** repeat and/or extend
*** `value!number` creates `number` events of type `value`.
*** `_` extends the duration of the previous event
    "bd*2 _ sn" = "bd bd sn"
**** Therefore this divides the first 2 of 5 into 3, and the last 3 of those 5 into 4.
     "sn:1*3 _ sn:1*4 _ _"
**** PITFALL : only extends the duration of the previous item *relative to others*.
     These two patterns sound the same:
     p 1 $ stack [ "[hh*4]",
                   "[bd*4] _" ]
     p 1 $ stack [ "[hh*4]",
                   "[bd*4]" ]
     That is, extending the number of time slots occupied by the [bd*4] from 1 to 2 does nothing, because there was previously only one slot, and now there are two.

     However, if there's something else for the bd*4 to vie for space with, then extending its length does have an effect -- hence the following are different.
     p 1 $ stack [ "[hh*4]",
                   "~ [bd*4]" ]
     p 1 $ stack [ "[hh*4]",
                   "~ [bd*4] _" ]
*** `event@number` makes `event` `number` times longer.
**** Therefore this divides the first 2 of 5 into 3, and the last 3 of those 5 into 4.
     "sn:1*3@2 sn:1*4@3"
** TODO rhythmically complex
*** (n,d) : Euclidean sequence with `n` events over time `d`
*** TODO {pat,pat, ... pat} polymeters
**** idea
     The patterns have different durations, but their first-level sub-events all have the same duration.
**** example
     In this:
       d1 $ s "{bd bd:1, cp cp:1 cp:2}"
     the second sequence takes 1.5 times as long as the first,
     and the time between bd events is the same as that between cp events.
**** PITFALL: Speed depends on the number of notes in the first pattern.
     If the first pattern has more top-level events,
     then all of them go faster.

     That's because first pattern will take one cycle to repeat.
     All the others depend on their relationship to it.
     For instance, in this pattern:

       do setcps 2
          d1 $ stack
            [ "{bd, sn:1 ~, ho ~ ~}"
            , "bleep" ]

     try changing the order of the {..} section.
*** TODO {pat}%number polymeters
    In
      d1 $ s "[{bd cp hh}%4, bass]"
    the bass happens every time four of the sounds from the first pattern
    have occurred.
* "Oscillators"
** range from 0 to 1 (always?)
** have a period equal to the unit cycle, I think
** there are two random ones : rand and irand
* TODO [[id:e0f7b428-c766-418b-96de-0d93a6484138]["state" in Tidal: cycle a list at each new note]]
* non-cyclic time in Tidal
** refs
*** transitions
    https://tidalcycles.org/docs/patternlib/tour/transitions/
*** "composition functions"
    https://tidalcycles.org/docs/reference/composition/
** TODO How are `anticipateIn` and `jumpIn` different?
** `once` is handy.
   It requires no pattern name, and can't be stopped.
   once $ s "trump"
** `xfade <voice name>` and `xfadeIn <number of cycles> <voice name>`
   p "drums" $ s "bd(3,8) drum*4"
   xfade "drums" $ s "arpy*8" # n (run 8)
** `clutch(In)`: Like `xfade(In)` using random grains instead of volume.
** `anticipate(In)`: apply pattern to voice in the future
** `interpolate(In)`: morph parameters
   d1 $ sound "arpy*16" # cutoff 100
   interpolate 1 $ sound "arpy*16" # cutoff 16000
** `jumpIn(')`: change patterns in the future.
   jumpIn' is aligned to cycle boundaries;
   jumpIn is not.
** TODO `jumpMod`: I don't understand.
** TODO `wait(In)`: not described
** the "composition" functions let you escape, somewhat, the looping paradigm
* some TidalCycles functions
** listToPat, fromList, fromMaybes and flatpat seem good
** quantise :: (Functor f, RealFrac b) => b -> f b -> f b
   Tell it what to round to multiples of.
** TODO every, spread and generally the "conditions" functions are what I want to generalize.
*** every
**** ::
     Pattern Int
     -> (Pattern a -> Pattern a)
     -> Pattern a
     -> Pattern a
**** is documented under "conditions"
     https://tidalcycles.org/docs/reference/conditions
**** every' lets you change its phase (very important!)
*** spread
**** ::
     (a -> t -> Pattern b)
     -> [a]
     -> t
     -> Pattern b
**** is documented under "alteration"
     https://tidalcycles.org/docs/reference/alteration
*** whenT
**** ::
     (Time -> Bool)
     -> (Pattern a -> Pattern a)
     -> Pattern a
     -> Pattern a
*** TODO within :: Arc -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
** trunc and linger are cool
   trunc takes a fraction in [0,1] and truncates the second argument that way.
   linger does similarly but repeats the head rather than going silent.
** TODO step' is like a sequencer
   This uses 0 to indicate superpiano, 1 for supermandolin.
   d1 $ s (step' ["superpiano","supermandolin"] "0 1 000 1")
        |* sustain 4 # n 0
** `|x|`, `|x` and `x|`, for all x
   On which side the bar lies determines which pattern divides time.
   If it's on both sides, both patterns divide time.
*** The examples in the documentation are helpful.
    https://tidalcycles.org/docs/patternlib/tutorials/pattern_structure
*** Two interesting operators: |> and <|
    They take values from one side but metric divisions from the other.
** `panic` is like `hush` but stronger.
   Even if samples get stuck, this works,
   because it (very quickly!) resets the synths.
** `fix f` applies `f` when specified conditions are met.
   https://userbase.tidalcycles.org/fix
** `cps` is a parameter, like `s` or `n` except global.
   Try it with oscillators (e.g. `saw` below).
   p "cpsfun" $ s "bd sd(3,8)" # cps (slow 8 $ 0.5 + saw)
** `timeloop` lets you periodically restart a cycle
   https://club.tidalcycles.org/t/restart-a-polymetric-sequence/3736
* some effects I like
  https://tidalcycles.org/docs/reference/audio_effects
** squiz
   Simplistic pitch shift via chopping.
   Try giving it even numbered values.
** the spectral conformer
   "real" and "imag"
   Applies the conformal map
   (the thing that makes Mandelbrot sets, I think).
   Weird vocoder artifacts.
** legato
   Based on my experiments, not code or documentation.
*** Says how long samples should last when interrupted.
    If less than one, the sample ends before interrupted.
    If 2, it lasts twice as long as it took to get interrupted.
    Etc.
** cut
   Assings the voice to a cut group.
   It will end as soon as anything else in the same cut group starts.
* [[id:e89c67a2-6f94-4466-8451-e7b03066aad1][continus parameter variation in Tidalcycles]]
* distortion in Tidal
  Probably [[id:d41a981f-1a73-44bf-85fb-f5a80d72bea3][the bus solution]] will do it.
  But see also
    /home/jeff/code/music/Tidal/distort-a-sum.tidal-SC
