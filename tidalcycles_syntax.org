:PROPERTIES:
:ID:       543397e7-733f-4d56-bf58-35f5e9d83b5e
:END:
#+title: TidalCycles language: syntax, functions, signal flow
* TODO questions
** What is the default amplitude?
   0.35?
* TODO [[id:e89c67a2-6f94-4466-8451-e7b03066aad1][continus parameter variation in Tidalcycles]]
* voices and signal flow in Tidal
** voice names
*** There are some "preassigned voices".
    `d1`, for instance.
    See BootTidal.hs for their definitions.
**** PITFALL: Preassigned voices also have voice names.
     The `voice name` for `d1`, for instance, is `1`.
     Sometimes a preassigned voice needs to be referred to via its name
     -- e.g. when using `xfade`.
*** Voice names can be dynamic and informative.
    Rather than use the preassigned voice names like `d1`,
    one can name patterns as in
      p 1
    or
      p "juliet"
** TODO There are effects buses.
   :PROPERTIES:
   :ID:       d41a981f-1a73-44bf-85fb-f5a80d72bea3
   :END:
   https://club.tidalcycles.org/t/creating-effects-chains-or-audio-buses/3707
   https://github.com/tidalcycles/tidal-doc/issues/66
* TidalCycles "mini-notation"
** DONE Each [] lasts as long as a single "event" in a pattern.
   So in "x [y z]" the x lasts as long as the [y z].
** Rationals are available!
   Just stick % between two integers.
** (.) can separate events like [] does.
   These are equivalent:
   "x . y z  . a b c"
   "x  [y z]  [a b c]"
** (,) joins events simultaneously
** TODO Things in a <> group are cycled through.
   This plays "bd" every time, "sd" one third of the times, etc:

   d1 $ s "bd <sd hh cp>"
** (|) randmonly chooses between things
   "[a | b] c" always plays c, sometimes plays a.
** TODO `value!number` creates `number` events of type `value`.
** TODO `_` looks like an event but continues the previous event
** TODO `event@number` makes `event` `number` times longer.
** postfix "?" sometimes replaces its argument with silence
** (sample:number) selects the `number`th value of that sample
** TODO (n,d) creates a Euclidean sequence with `n` events covering time `d`.
** TODO {pat,pat, ... pat} polymeters
*** idea
    The patterns have different durations, but their first-level sub-events all have the same duration.
*** example
    In this:
      d1 $ s "{bd bd:1, cp cp:1 cp:2}"
    the second sequence takes 1.5 times as long as the first,
    and the time between bd events is the same as that between cp events.
** TODO {pat}%number polymeters
   In
     d1 $ s "[{bd cp hh}%4, bass]"
   the bass happens every time four of the sounds from the first pattern
   have occurred.
* cyclic time in Tidal
** _ extends the duration of the previous item, *only relative to others*.
   These two patterns sound the same:
   p 1 $ stack [ "[hh*4]",
                 "[bd*4] _" ]
   p 1 $ stack [ "[hh*4]",
                 "[bd*4]" ]
   That is, extending the number of time slots occupied by the [bd*4] from 1 to 2 does nothing, because there was previously only one slot, and now there are two.

   However, if there's something else for the bd*4 to vie for space with, then extending its length does have an effect -- hence the following are different.
   p 1 $ stack [ "[hh*4]",
                 "~ [bd*4]" ]
   p 1 $ stack [ "[hh*4]",
                 "~ [bd*4] _" ]
* non-cyclic time in Tidal
** refs
*** transitions
    https://tidalcycles.org/docs/patternlib/tour/transitions/
*** "composition functions"
    https://tidalcycles.org/docs/reference/composition/
** TODO How are `anticipateIn` and `jumpIn` different?
** `once` is handy.
   It requires no pattern name, and can't be stopped.
   once $ s "trump"
** `xfade <voice name>` and `xfadeIn <number of cycles> <voice name>`
   p "drums" $ s "bd(3,8) drum*4"
   xfade "drums" $ s "arpy*8" # n (run 8)
** `clutch(In)`: Like `xfade(In)` using random grains instead of volume.
** `anticipate(In)`: apply pattern to voice in the future
** `interpolate(In)`: morph parameters
   d1 $ sound "arpy*16" # cutoff 100
   interpolate 1 $ sound "arpy*16" # cutoff 16000
** `jumpIn(')`: change patterns in the future.
   jumpIn' is aligned to cycle boundaries;
   jumpIn is not.
** TODO `jumpMod`: I don't understand.
** TODO `wait(In)`: not described
** the "composition" functions let you escape, somewhat, the looping paradigm
* TODO NEW: State
  Supposedly makes it easier to line things up.
  https://tidalcycles.org/docs/reference/state_values
* some TidalCycles functions
** listToPat, fromList, fromMaybes and flatpat seem good
** quantise :: (Functor f, RealFrac b) => b -> f b -> f b
   Tell it what to round to multiples of.
** TODO every, spread and generally the "conditions" functions are what I want to generalize.
*** every
**** ::
     Pattern Int
     -> (Pattern a -> Pattern a)
     -> Pattern a
     -> Pattern a
**** is documented under "conditions"
     https://tidalcycles.org/docs/reference/conditions
**** every' lets you change its phase (very important!)
*** spread
**** ::
     (a -> t -> Pattern b)
     -> [a]
     -> t
     -> Pattern b
**** is documented under "alteration"
     https://tidalcycles.org/docs/reference/alteration
*** whenT
**** ::
     (Time -> Bool)
     -> (Pattern a -> Pattern a)
     -> Pattern a
     -> Pattern a
*** TODO within :: Arc -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
** trunc and linger are cool
   trunc takes a fraction in [0,1] and truncates the second argument that way.
   linger does similarly but repeats the head rather than going silent.
** TODO step' is like a sequencer
   This uses 0 to indicate superpiano, 1 for supermandolin.
   d1 $ s (step' ["superpiano","supermandolin"] "0 1 000 1")
        |* sustain 4 # n 0
** `|x|`, `|x` and `x|`, for all x
   On which side the bar lies determines which pattern divides time.
   If it's on both sides, both patterns divide time.
*** The examples in the documentation are helpful.
    https://tidalcycles.org/docs/patternlib/tutorials/pattern_structure
*** Two interesting operators: |> and <|
    They take values from one side but metric divisions from the other.
** `panic` is like `hush` but stronger.
   Even if samples get stuck, this works,
   because it (very quickly!) resets the synths.
** `fix f` applies `f` when specified conditions are met.
   https://userbase.tidalcycles.org/fix
** `cps` is a parameter, like `s` or `n` except global.
   Try it with oscillators (e.g. `saw` below).
   p "cpsfun" $ s "bd sd(3,8)" # cps (slow 8 $ 0.5 + saw)
** `timeloop` lets you periodically restart a cycle
   https://club.tidalcycles.org/t/restart-a-polymetric-sequence/3736
* some effects I like
  https://tidalcycles.org/docs/reference/audio_effects
** squiz
   Simplistic pitch shift via chopping.
   Try giving it even numbered values.
** the spectral conformer
   "real" and "imag"
   Applies the conformal map
   (the thing that makes Mandelbrot sets, I think).
   Weird vocoder artifacts.
* some code maybe worth hacking
** `histpan` is a transition function that pans repetitions of a pattern.
   I might want to do that with other parameters.
